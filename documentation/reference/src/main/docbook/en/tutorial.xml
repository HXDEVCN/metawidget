<?xml version="1.0" encoding="UTF-8"?>
	<chapter id="chapter-introduction">
		<title>Introduction to Metawidget</title>

		<para>
			This chapter is an introductory tutorial for new users of
			Metawidget. Before you begin, you need to download the binary distribution from
			<ulink url="http://metawidget.org/download.php">http://metawidget.org/download.php</ulink>.
		</para>
		
		<para>
			If you are using a Java-based framework (including Android, and Java-based web frameworks
			such as GWT or Java Server Faces) you should follow <xref linkend="section-introduction-java-part1" />. If you
			are using a pure JavaScript-based framework (such as AngularJS or JQuery Mobile) you should follow
			<xref linkend="section-introduction-javascript-part1" />. 
		</para>

		<section id="section-introduction-java-part1">
			<title>Part 1 (Java version) - The First Metawidget Application</title>

			<para>
				Part 1 starts with a simple Swing application and develops it in easy to understand steps.
				Metawidget supports many Java-based UI frameworks, not just Swing, but we start with Swing because it
				ships with Java SE and requires minimal setup.
			</para>

			<para>
				This tutorial should take around 20 minutes. We recommend you use your preferred Java
				development environment. If you use an Integrated Development Environment (IDE), you will
				need to start a new Java project and add <filename>metawidget-all.jar</filename> to it. Otherwise,
				you just need to ensure <filename>metawidget-all.jar</filename> is on your <parameter>CLASSPATH</parameter>.
			</para>

			<section id="section-introduction-java-part1-object">
				<title>The Object</title>

				<para>
					Metawidget is an Object/User Interface Mapping tool (OIM), so first we need an object to map from - the
					<emphasis>O</emphasis> in OIM. Create a class in your project called <classname>Person</classname>
					with the following code:
				</para>

				<programlisting language="java">package com.myapp;

public class Person {
	private String	mName;
	private int		mAge;
	private boolean	mRetired;

	public String getName() { return mName; }
	public void setName( String name ) { mName = name; }

	public int getAge() { return mAge; }
	public void setAge( int age ) { mAge = age; }

	public boolean isRetired() { return mRetired; }
	public void setRetired( boolean retired ) { mRetired = retired; }
}</programlisting>

			</section>

			<section id="section-introduction-java-part1-interface">
				<title>The Interface</title>

				<para>
					Next we need a User Interface framework - the <emphasis>I</emphasis>
					in OIM. Create a class in your project called <classname>Main</classname>
					with the following code:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<tip>
					<title>Note</title>
					Many IDEs include visual UI builders
					for dragging and dropping widgets. Metawidget integrates
					with these tools and Metawidgets can be dragged and
					dropped like any other. As we shall see, however, Metawidget
					widgets automatically fill themselves with child widgets at runtime,
					saving significant development time.
				</tip>

			</section>

			<section id="section-introduction-java-part1-output">
				<title>The Output</title>

				<para>
					If you're using an IDE, such as	<ulink url="http://netbeans.org">NetBeans</ulink>, your project should
					look something like pictured in	<xref linkend="section-introduction-java-part1-screenshot-ide" />.
				</para>

				<figure id="section-introduction-java-part1-screenshot-ide">
					<title>Metawidget tutorial in NetBeans IDE</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial-ide.jpg" width="170mm" />
					</screenshot>
				</figure>

				<para>
					Run the code. You should see the screen in <xref linkend="section-introduction-java-part1-screenshot1" />.
				</para>

				<figure id="section-introduction-java-part1-screenshot1">
					<title>SwingMetawidget rendering of Person class</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial1.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					The <classname>SwingMetawidget</classname> has automatically populated itself with child widgets at
					runtime. It has chosen <classname>JSpinner</classname>,	<classname>JTextField</classname> and
					<classname>JCheckBox</classname> widgets based on the types of the properties of the
					<classname>Person</classname> class. This is the First Goal Of Metawidget:
				</para>

				<important>
					<title>First Goal Of Metawidget</title>
					Metawidget creates UI widgets by inspecting existing architectures
				</important>

				<para>
					By default, <classname>SwingMetawidget</classname> has laid out the	<classname>JComponent</classname>s
					using <classname>java.awt.GridBagLayout</classname>. Try resizing the window, and the
					<classname>JComponent</classname>s will resize with it. If you've ever tried using
					<classname>java.awt.GridBagLayout</classname> yourself, either
					through code or a visual UI builder, you'll know how fiddly it can be. Having Metawidget do it for you is a real time-saver.
				</para>

				<para>
					Clearly this is not a complete UI. There are no Save or Cancel buttons, for example,
					and the	<classname>JComponent</classname>s appear uncomfortably tight to the left, top and right edges of the
					<classname>JFrame</classname>. This is explained by the Second Goal Of Metawidget:
				</para>

				<important>
					<title>Second Goal Of Metawidget</title>
					Metawidget does not try to 'own' the entire UI - it focuses on
					creating native sub-widgets for slotting into existing UIs
				</important>

				<para>
					You slot Metawidget alongside your standard UI components, often combining several Metawidgets on the same screen. We'll
					see how this works later.
				</para>

			</section>

			<section id="section-introduction-java-part1-ordering">
				<title>Ordering The Properties</title>

				<para>
					Currently the <parameter>name</parameter>, <parameter>age</parameter>
					and	<parameter>retired</parameter> properties are arranged alphabetically in the UI - their order does not match
					the way they are defined in the	<classname>Person</classname>
					class. This is because property ordering information is not retained within Java class files
					(as per the Java Language Specification).
				</para>

				<para>
					To correct this, Metawidget needs to gather additional information. There are several ways to
					do this (i.e. you don't have to use annotations), but the simplest for now is to use the built-in
					Metawidget annotation <classname>@UiComesAfter</classname>.
				</para>

				<para>
					Annotate the <classname>Person</classname>
					class as shown below (lines to add are highlighted):
				</para>

				<programlisting language="java">package com.myapp;

<symbol>import org.metawidget.inspector.annotation.*;</symbol>

public class Person {
	private String	mName;
	private int		mAge;
	private boolean	mRetired;

	public String getName() { return mName; }
	public void setName( String name ) { mName = name; }

	<symbol>@UiComesAfter( "name" )</symbol> <co id="co-introduction-part1-annotations" linkends="ca-introduction-part1-annotations" />
	public int getAge() { return mAge; }
	public void setAge( int age ) { mAge = age; }

	<symbol>@UiComesAfter( "age" )</symbol>
	public boolean isRetired() { return mRetired; }
	public void setRetired( boolean retired ) { mRetired = retired; }
}</programlisting>

				<calloutlist>
					<callout arearefs="co-introduction-part1-annotations" id="ca-introduction-part1-annotations">
						<para>
							Annotations can also be applied to the private fields, such as <parameter>mAge</parameter>,
							but that requires a little extra configuration.
						</para>
					</callout>
				</calloutlist>

				<para>
					Run the code again. This time the properties appear in the correct order:
				</para>

				<figure id="section-introduction-java-part1-ordered-screenshot2">
					<title>Properties in correct order</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial2.jpg" width="100mm" />
					</screenshot>
				</figure>
			</section>

			<section id="section-introduction-java-part1-inspectors">
				<title>Inspectors</title>

				<para>
					Introducing new annotations to improve the UI is not really in the spirit of
					the First Goal Of Metawidget. We'd much rather improve it by gathering
					information from <emphasis>existing</emphasis> sources. To demonstrate, we'll need an external source of metadata. Create a file
					called <filename>metawidget-metadata.xml</filename> in the same folder as your <classname>Main</classname> class:
				</para>
	
				<programlisting language="xml">&lt;inspection-result xmlns="http://metawidget.org/inspection-result"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"	
	xsi:schemaLocation="http://metawidget.org/inspection-result
		http://metawidget.org/xsd/inspection-result-1.0.xsd"&gt;

	&lt;entity type="com.myapp.Person"&gt;
		&lt;property name="name"/&gt;
		&lt;property name="age"/&gt;
		&lt;property name="retired"/&gt;
	&lt;/entity&gt;

&lt;/inspection-result&gt;</programlisting>
	
				<para>
					To recognise the XML file, Metawidget needs to use a different <emphasis>Inspector</emphasis>.
					Metawidget comes with multiple <classname>Inspector</classname>s, each
					targeting different sources of information. Change the <classname>Main</classname> class to use an
					<classname>XmlInspector</classname> (lines to add are highlighted):
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
<symbol>import org.metawidget.inspector.xml.*;</symbol>
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>XmlInspectorConfig config = new XmlInspectorConfig();
		config.setInputStream( Main.class.getResourceAsStream( "metawidget-metadata.xml" ));
		metawidget.setInspector( new XmlInspector( config ) );</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Then remove all annotations from the <classname>Person</classname> class:
				</para>
				
				<programlisting language="java">package com.myapp;

public class Person {
	private String	mName;
	private int		mAge;
	private boolean	mRetired;

	public String getName() { return mName; }
	public void setName( String name ) { mName = name; }

	public int getAge() { return mAge; }
	public void setAge( int age ) { mAge = age; }

	public boolean isRetired() { return mRetired; }
	public void setRetired( boolean retired ) { mRetired = retired; }
}</programlisting>
				
				<para>
					Run the code again. It does not yield the correct result - the properties appear
					in the correct order, but the <classname>JSpinner</classname> and
					<classname>JCheckBox</classname> are now <classname>JTextField</classname>s!
					What happened?
				</para>
	
				<figure id="section-introduction-java-part1-screenshot3">
					<title>Correct property order, but wrong JComponents</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial3.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Metawidget <classname>Inspector</classname>s are very targeted in what they inspect.
					<classname>XmlInspector</classname> looks for metadata from XML files - but it does
					<emphasis>not</emphasis> look for anything else, such as JavaBean property types.
					Before we explicitly specified an
					<classname>XmlInspector</classname>, Metawidget had been implictly using two
					<classname>Inspector</classname>s for us, called <classname>PropertyTypeInspector</classname>
					and	<classname>MetawidgetAnnotationInspector</classname>.
				</para>

			</section>

			<section id="section-introduction-java-part1-compositeinspector">
				<title>Combining Multiple Inspection Results</title>

				<para>
					What we need is to <emphasis>combine</emphasis> the results of
					<classname>PropertyTypeInspector</classname>, <classname>MetawidgetAnnotationInspector</classname>
					and	<classname>XmlInspector</classname> before returning them to
					<classname>SwingMetawidget</classname>. We do this using <classname>CompositeInspector</classname>:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
<symbol>import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.propertytype.*;</symbol>
import org.metawidget.inspector.xml.*;
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		XmlInspectorConfig config = new XmlInspectorConfig();
		config.setInputStream( Main.class.getResourceAsStream( "metawidget-metadata.xml" ));		
		<symbol>CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new XmlInspector( config ),
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code again. This time properties appear both in the correct order
					and using the correct <classname>JComponent</classname>:
				</para>

				<figure id="section-introduction-java-part1-screenshot4">
					<title>Using multiple inspectors</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial4.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					This idea of combining multiple <classname>Inspector</classname>s to inspect different characteristics of your
					existing architecture is very powerful. Metawidget comes with pre-written
					<classname>Inspector</classname>s for many different technologies - from JPA and Hibernate Validator annotations,
					to <filename>struts-config.xml</filename> configuration files, to Groovy and Scala properties.
					There is a lot of metadata already lurking in back-end
					systems - it just needs extracting. For example, <classname>JpaInspector</classname> understands this...
				</para>
				
				<programlisting language="java">import javax.persistence.Column;

public class Person {
	@Column( nullable = false )
	public String getName() { ... };
}</programlisting>
	
				<para>
					...denotes <parameter>name</parameter> is a required property (could be rendered with an asterisk after it in the UI). Equally,
					<classname>PropertyTypeInspector</classname> understands that...
				</para>
				
				<programlisting language="java">public class Person {
	private String mName;
	
	public String getName() {
		return mName;
	}
	
	// No setter
}</programlisting>
	
				<para>
					...signifies <parameter>name</parameter> is a read-only property (could be rendered as a label in the UI).
				</para>
				
			</section>

			<section id="section-introduction-java-part1-layout">
				<title>Controlling The Layout</title>

				<para>
					There are several ways to control the layout of the components. To demonstrate, Try adding the following
					properties to the Person class:
				</para>

				<programlisting language="java">package com.myapp;

<symbol>import org.metawidget.inspector.annotation.*;</symbol>

public class Person {

	<symbol>public enum Gender { Male, Female }</symbol>
	
	private String	mName;
	private int		mAge;
	private boolean	mRetired;
	<symbol>private Gender	mGender;
	private String	mNotes;
	private String	mEmployer;
	private String	mDepartment;</symbol>
	
	public String getName() { return mName; }
	public void setName( String name ) { mName = name; }

	public int getAge() { return mAge; }
	public void setAge( int age ) { mAge = age; }

	public boolean isRetired() { return mRetired; }
	public void setRetired( boolean retired ) { mRetired = retired; }

	<symbol>@UiComesAfter( "retired" ) <co id="co-introduction-part1-annotations2" linkends="ca-introduction-part1-annotations2" />
	public Gender getGender() { return mGender; }
	public void setGender( Gender gender ) { mGender = gender; }

	@UiComesAfter( "gender" )
	@UiLarge
	public String getNotes() { return mNotes; }
	public void setNotes( String notes ) { mNotes = notes; }

	@UiComesAfter( "notes" )
	@UiSection( "Work" )
	public String getEmployer() { return mEmployer; }
	public void setEmployer( String employer ) { mEmployer = employer; }

	@UiComesAfter( "employer" )
	public String getDepartment() { return mDepartment; }
	public void setDepartment( String department ) { mDepartment = department; }</symbol>
}</programlisting>

				<calloutlist>
					<callout arearefs="co-introduction-part1-annotations2" id="ca-introduction-part1-annotations2">
						<para>
							We'll use annotations again for brevity. But such metadata could
							be inspected from any source, such as an XML file.
						</para>
					</callout>
				</calloutlist>

				<para>
					This code produces the screen in <xref linkend="section-introduction-java-part1-screenshot5" />. Annotations
					have been used to define section headings and 'large' properties (i.e. a <classname>JTextArea</classname>).
				</para>

				<figure id="section-introduction-java-part1-screenshot5">
					<title>Additional properties and a section heading</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial5.jpg" width="100mm" />
					</screenshot>
				</figure>

				<tip>
					<title>Note</title>
					For a list of all the annotations <classname>MetawidgetAnnotationInspector</classname> recognises,
					see	<xref linkend="section-inspectors-metawidgetannotation" />.
				</tip>

				<para>
					By default,	<classname>SwingMetawidget</classname> lays out
					<classname>JComponent</classname>s using <classname>org.metawidget.swing.layout.GridBagLayout</classname>.
					You can configure this layout, or swap it for a different layout, using
					<function>SwingMetawidget.setMetawidgetLayout</function>. Modify the code to use a
					<classname>GridBagLayout</classname> with 2 columns:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.xml.*;
import org.metawidget.swing.*;
<symbol>import org.metawidget.swing.layout.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		XmlInspectorConfig config = new XmlInspectorConfig();
		config.setInputStream( Main.class.getResourceAsStream( "metawidget-metadata.xml" ));		
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new XmlInspector( config ),
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		<symbol>GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		SeparatorLayoutDecoratorConfig layoutConfig = new SeparatorLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new SeparatorLayoutDecorator( layoutConfig ));</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <classname>JComponent</classname>s are now arranged across two columns:
				</para>

				<figure id="section-introduction-java-part1-screenshot6">
					<title>A two-column layout</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial6.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					You may have noticed the <classname>GridBagLayout</classname> is nested inside a <classname>SeparatorLayoutDecorator</classname>. This
					is responsible for separating widgets in different sections using <classname>JSeparator</classname>s. However there are other choices for
					separating widgets. Modify the code to use <classname>TabbedPaneLayoutDecorator</classname> instead:
				</para>
				
				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.xml.*;
import org.metawidget.swing.*;
import org.metawidget.swing.layout.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		XmlInspectorConfig config = new XmlInspectorConfig();
		config.setInputStream( Main.class.getResourceAsStream( "metawidget-metadata.xml" ));		
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new XmlInspector( config ),
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		<symbol>TabbedPaneLayoutDecoratorConfig layoutConfig = new TabbedPaneLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new TabbedPaneLayoutDecorator( layoutConfig ));</symbol>
		metawidget.setToInspect( person );
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The section heading is now a <classname>JTabbedPane</classname>:
				</para>

				<figure id="section-introduction-java-part1-screenshot7">
					<title>Two-column layout with a JTabbedPane</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial7.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Again, if you've ever used <classname>java.awt.GridBagLayout</classname> by hand, you'll appreciate how much easier
					Metawidget makes it to apply consistent layouts across all screens of your application.
				</para>
					
			</section>

			<section id="section-introduction-java-part1-creation">
				<title>Controlling Widget Creation</title>

				<para>
					There are several ways to control widget creation. One way is to drop child controls inside the
					<classname>SwingMetawidget</classname>. This approach works well both programmatically
					within code and within visual UI builders.
				</para>

				<para>
					Modify the code to add a <classname>JComboBox</classname> to the Metawidget:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.xml.*;
import org.metawidget.swing.*;
import org.metawidget.swing.layout.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		XmlInspectorConfig config = new XmlInspectorConfig();
		config.setInputStream( Main.class.getResourceAsStream( "metawidget-metadata.xml" ));		
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new XmlInspector( config ),
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		TabbedPaneLayoutDecoratorConfig layoutConfig = new TabbedPaneLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new TabbedPaneLayoutDecorator( layoutConfig ));
		metawidget.setToInspect( person );
		<symbol>JComboBox combo = new JComboBox();
		combo.setName( "retired" );
		metawidget.add( combo );</symbol>
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <classname>JComboBox</classname> appears in place of the
					<parameter>retired</parameter> <classname>JCheckBox</classname>, because it has the same name (i.e. 'retired') as Metawidget would have given the
					<classname>JCheckbox</classname>:
				</para>

				<figure id="section-introduction-java-part1-screenshot8">
					<title>The 'retired' property has been overridden</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial8.jpg" width="100mm" />
					</screenshot>
				</figure>

				<tip>
					<title>Note</title>
					The default algorithm looks for child controls with the same name, but you can plug in your own implementation
					if you need to. See <xref linkend="section-architecture-overriddenwidgetbuilder"/>.
				</tip>
				
				<para>
					To suppress a widget's creation entirely, simply supplying an empty
					<classname>JPanel</classname> named 'retired' will not work as Metawidget
					will still create an accompanying label in the left hand column. Instead, Metawidget includes special
					<classname>Stub</classname> widgets	for this purpose:
				</para>

				<programlisting language="java">package com.myapp;

import javax.swing.*;
import org.metawidget.inspector.annotation.*;
import org.metawidget.inspector.composite.*;
import org.metawidget.inspector.propertytype.*;
import org.metawidget.inspector.xml.*;
import org.metawidget.swing.*;

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();
		
		SwingMetawidget metawidget = new SwingMetawidget();
		XmlInspectorConfig config = new XmlInspectorConfig();
		config.setInputStream( Main.class.getResourceAsStream( "metawidget-metadata.xml" ));		
		CompositeInspectorConfig inspectorConfig = new CompositeInspectorConfig().setInspectors(
			new XmlInspector( config ),
			new PropertyTypeInspector(),
			new MetawidgetAnnotationInspector() );
		metawidget.setInspector( new CompositeInspector( inspectorConfig ) );
		GridBagLayoutConfig nestedLayoutConfig = new GridBagLayoutConfig().setNumberOfColumns( 2 ); 
		TabbedPaneLayoutDecoratorConfig layoutConfig = new TabbedPaneLayoutDecoratorConfig().setLayout(
			new org.metawidget.swing.layout.GridBagLayout( nestedLayoutConfig ));
		metawidget.setMetawidgetLayout( new TabbedPaneLayoutDecorator( layoutConfig ));
		metawidget.setToInspect( person );
		<symbol>metawidget.add( new Stub( "retired" ));</symbol>
		
		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The <parameter>retired</parameter> property and its label will not appear:
				</para>

				<figure id="section-introduction-java-part1-screenshot9">
					<title>The 'retired' property has been suppressed</title>
					<screenshot>
						<graphic fileref="images/screenshots/swing-tutorial9.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Another way is to use a <classname>@UiHidden</classname> annotation on the business class:
				</para>

				<programlisting language="java">package com.myapp;

import org.metawidget.inspector.annotation.*;

public class Person {

	public enum Gender { Male, Female }
	
	private String	mName;
	private int		mAge;
	private boolean	mRetired;
	private Gender	mGender;
	private String	mNotes;
	private String	mEmployer;
	private String	mDepartment;
	
	public String getName() { return mName; }
	public void setName( String name ) { mName = name; }

	public int getAge() { return mAge; }
	public void setAge( int age ) { mAge = age; }

	<symbol>@UiHidden</symbol>
	public boolean isRetired() { return mRetired; }
	public void setRetired( boolean retired ) { mRetired = retired; }

	@UiComesAfter( "retired" )
	public Gender getGender() { return mGender; }
	public void setGender( Gender gender ) { mGender = gender; }

	@UiComesAfter( "gender" )
	@UiLarge
	public String getNotes() { return mNotes; }
	public void setNotes( String notes ) { mNotes = notes; }

	@UiComesAfter( "notes" )
	@UiSection( "Work" )
	public String getEmployer() { return mEmployer; }
	public void setEmployer( String employer ) { mEmployer = employer; }

	@UiComesAfter( "employer" )
	public String getDepartment() { return mDepartment; }
	public void setDepartment( String department ) { mDepartment = department; }
}</programlisting>

				<para>
					In both cases, <classname>org.metawidget.swing.layout.GridBagLayout</classname>
					is smart enough to always give large <classname>JComponent</classname>s
					like <parameter>notes</parameter> the full width of the
					<classname>JFrame</classname>.
				</para>

			</section>

			<section id="section-introduction-java-part1-metawidget-config">
				<title>Configuring Metawidget Externally</title>

				<para>
					So far we have been instantiating our <classname>Inspector</classname>s and
					<classname>Layout</classname>s in Java code. Whilst this approach is possible for all
					<classname>Inspector</classname>s and <classname>Layout</classname>s, many UI frameworks employ
					visual UI builders or intermediate languages (such as JSP) that make getting to the Java code cumbersome (i.e. you have to derive
					custom widgets).
				</para>

				<para>
					As an alternative, Metawidget supports external XML configuration. Create a file called
					<filename>metawidget.xml</filename> in the same folder as your <classname>Main</classname>
					class:
				</para>

				<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

	&lt;swingMetawidget xmlns="java:org.metawidget.swing"&gt;		
		&lt;inspector&gt;
			&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
				config="CompositeInspectorConfig"&gt;
				&lt;inspectors&gt;
					&lt;array&gt;
						&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml" config="XmlInspectorConfig"&gt;
							&lt;inputStream&gt;
								&lt;resource&gt;com/myapp/metawidget-metadata.xml&lt;/resource&gt;
							&lt;/inputStream&gt;
						&lt;/xmlInspector&gt;
						&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
						&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation" /&gt;
					&lt;/array&gt;
				&lt;/inspectors&gt;
			&lt;/compositeInspector&gt;
		&lt;/inspector&gt;
		&lt;metawidgetLayout&gt;
			&lt;tabbedPaneLayoutDecorator xmlns="java:org.metawidget.swing.layout"
				config="TabbedPaneLayoutDecoratorConfig"&gt;
				&lt;layout&gt;
					&lt;gridBagLayout config="GridBagLayoutConfig"&gt;
						&lt;numberOfColumns&gt;
							&lt;int&gt;2&lt;/int&gt;
						&lt;/numberOfColumns&gt;
					&lt;/gridBagLayout&gt;
				&lt;/layout&gt;
			&lt;/tabbedPaneLayoutDecorator&gt;
		&lt;/metawidgetLayout&gt;	
	&lt;/swingMetawidget&gt;

&lt;/metawidget&gt;</programlisting>			
				
				<para>
					Now update your <classname>Main</classname> class to use this file:
				</para>
					
				<programlisting language="java">package com.myapp;

<symbol>import javax.swing.*;
import org.metawidget.swing.*;</symbol>

public class Main {

	public static void main( String[] args ) {
		Person person = new Person();

		SwingMetawidget metawidget = new SwingMetawidget();
		<symbol>metawidget.setConfig( "com/myapp/metawidget.xml" );</symbol>
		metawidget.setToInspect( person );

		JFrame frame = new JFrame( "Metawidget Tutorial" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		frame.getContentPane().add( metawidget );
		frame.setSize( 400, 250 );
		frame.setVisible( true );
	}
}</programlisting>

				<para>
					Run the code. The output is the same as before, but this time we are configuring our Metawidget via external XML.
				</para>
				
				<para>
					Visual UI builders can call <function>SwingMetawidget.setConfig</function> from the builder, with no coding required. Other
					UI frameworks (e.g. JSPs, Android) have similar 'code free' approaches (e.g. setting an attribute on a JSP tag, setting an
					attribute in an Android layout file) to setting the XML file. We shall look at these sorts of frameworks in Part 2.
				</para>
				
			</section>
			
			<para>
				Now skip to <xref linkend="section-introduction-part2" />
			</para>
			
		</section>

		<section id="section-introduction-javascript-part1">
			<title>Part 1 (JavaScript version) - The First Metawidget Application</title>

			<para>
				Part 1 starts with a pure JavaScript application and develops it in easy to understand steps.
				Metawidget supports many JavaScript-based UI frameworks, but we start with pure JavaScript because it
				requires minimal setup.
			</para>

			<para>
				This tutorial should take around 20 minutes. We recommend you use your preferred JavaScript
				development environment.
			</para>

			<section id="section-introduction-javascript-part1-object">
				<title>The Object</title>

				<para>
					Metawidget is an Object/User Interface Mapping tool (OIM), so first we need an object to map from - the
					<emphasis>O</emphasis> in OIM. Create a new HTML page in your project called <classname>index.html</classname>
					with the following code:
				</para>

				<programlisting language="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;script type="text/javascript"&gt;
			var person = {
				name: "Homer Simpson",
				age: 40,
				retired: false
			};
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;</programlisting>

			</section>

			<section id="section-introduction-javascript-part1-interface">
				<title>The Interface</title>

				<para>
					Next we need a User Interface - the <emphasis>I</emphasis>
					in OIM. Add the following code to your HTML page
					(lines to add are highlighted):
				</para>

				<programlisting language="java">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		<symbol>&lt;script src="lib/metawidget/core/metawidget-core.min.js" type="text/javascript"&gt;&lt;/script&gt;</symbol>
		&lt;script type="text/javascript"&gt;
			var person = {
				name: "Homer Simpson",
				age: 40,
				retired: false
			};
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		<symbol>&lt;div id="metawidget"&gt;&lt;/div&gt;
		&lt;script type="text/javascript"&gt;
			var mw = new metawidget.Metawidget( document.getElementById( 'metawidget' ));
			mw.toInspect = person;
			mw.buildWidgets();
		&lt;/script&gt;</symbol>
	&lt;/body&gt;
&lt;/html&gt;</programlisting>

				<para>
					You will also need to copy <filename>js/lib/metawidget/core/metawidget-core.min.js</filename> from
					the Metawidget binary distribution into your project.
				</para>
				
			</section>

			<section id="section-introduction-javascript-part1-output">
				<title>The Output</title>

				<para>
					Open your HTML page in your browser.
					You should see the page in <xref linkend="section-introduction-javascript-part1-screenshot1" />.
				</para>

				<figure id="section-introduction-javascript-part1-screenshot1">
					<title>Metawidget rendering of person object</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial1.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Metawidget has automatically populated the <parameter>div</parameter> with child widgets at
					runtime. It has chosen <parameter>text</parameter>, <parameter>number</parameter> and <parameter>checkbox</parameter>
					inputs based on the types of the properties of the <parameter>person</parameter> object. This
					is the First Goal Of Metawidget: 
				</para>

				<important>
					<title>First Goal Of Metawidget</title>
					Metawidget creates UI widgets by inspecting existing architectures
				</important>

				<para>
					By default, Metawidget has laid out the	HTML <parameter>input</parameter> components
					using a <parameter>table</parameter>. This may not be your preferred approach, and
					either way this is clearly not a complete UI. There are no Save or Cancel buttons, for example.
					This is explained by the Second Goal Of Metawidget:
				</para>

				<important>
					<title>Second Goal Of Metawidget</title>
					Metawidget does not try to 'own' the entire UI - it focuses on
					creating native sub-widgets for slotting into existing UIs
				</important>

				<para>
					You slot Metawidget alongside your standard UI components, often combining several
					Metawidgets on the same screen. We'll see how this works later.
				</para>

			</section>

			<section id="section-introduction-javascript-part1-inspectors">
				<title>Inspectors</title>

				<para>
					Suppose we want the <parameter>name</parameter> property to be a required field. Such
					metadata cannot be represented using standard JavaScript Object Notation (JSON) so
					Metawidget needs a way to gather the additional information. There are several ways to do this, but the simplest
					for now is to add a custom <emphasis>Inspector</emphasis> (text to add is highlighted) that returns
					a <ulink url="http://json-schema.org">JSON Schema</ulink>:
				</para>
				
				<programlisting language="xml">var mw = new metawidget.Metawidget( document.getElementById( 'metawidget' )<symbol>, {
	
	inspector: function( toInspect, type, names ) {

		return {
			properties: {
				name: {
					type: "string",
					required: true
				}
			}
		};
	}
}</symbol> );</programlisting>
				
				<para>
					Refresh the page in your browser. It does not yield the correct result - the <parameter>name</parameter>
					property appears as a required field, but the <parameter>age</parameter> and <parameter>retired</parameter>					
					properties have disappeared! What happened?
				</para>
	
				<figure id="section-introduction-javascript-part1-screenshot2">
					<title>Name is required, but other properties are missing</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial2.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Metawidget <classname>Inspector</classname>s are very targeted in what they inspect.
					Our custom <classname>Inspector</classname> returns information about <parameter>name</parameter>
					being a required field - but it does
					<emphasis>not</emphasis> return anything else, such as properties from our JSON object.
					Before we explicitly specified a new <classname>Inspector</classname>, Metawidget had
					been implictly using another <classname>Inspector</classname> for us,
					called <classname>PropertyTypeInspector</classname>.
				</para>

			</section>

			<section id="section-introduction-javascript-part1-compositeinspector">
				<title>Combining Multiple Inspection Results</title>

				<para>
					What we need is to <emphasis>combine</emphasis> the results of
					<classname>PropertyTypeInspector</classname> and our custom
					<classname>Inspector</classname> before returning them to the
					Metawidget. We do this using <classname>CompositeInspector</classname>:
				</para>

				<programlisting language="java">var mw = new metawidget.Metawidget( document.getElementById( 'metawidget' ), {
	
	inspector: <symbol>new metawidget.inspector.CompositeInspector( [ new metawidget.inspector.PropertyTypeInspector(),</symbol>
		function( toInspect, type, names ) {
		
				return {
					properties: {					
						name: {
							<symbol><emphasis role="strike">type: "string",</emphasis></symbol> <co id="co-introduction-javascript-part1-compositeinspector" linkends="ca-introduction-javascript-part1-compositeinspector" />
							required: true
						}
					}
				};
			}
		}
	<symbol>] )</symbol>
} );</programlisting>

				<calloutlist>
					<callout arearefs="co-introduction-javascript-part1-compositeinspector" id="ca-introduction-javascript-part1-compositeinspector">
						<para>
							<parameter>type</parameter> can now be removed from our custom <classname>Inspector</classname>, as it will
							be looked up by <classname>PropertyTypeInspector</classname>.
						</para>
					</callout>
				</calloutlist>

				<para>
					Refresh the page again. This time all properties appear and <parameter>name</parameter>
					is marked as a required field.
				</para>

				<figure id="section-introduction-javascript-part1-screenshot3">
					<title>Using multiple inspectors</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial3.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					This idea of combining multiple <classname>Inspector</classname>s to inspect different characteristics of your
					existing architecture is very powerful. Metawidget comes with pre-written
					<classname>Inspector</classname>s for many different technologies and makes it easy to
					add your own, such as for REST services (see <xref linkend="section-inspectionresultprocessors-rest"/>).
					There is a lot of metadata already lurking in back-end
					systems - it just needs extracting.
				</para>				
			</section>

			<section id="section-introduction-javascript-part1-layout">
				<title>Controlling The Layout</title>

				<para>
					There are several ways to control the layout of the components. To demonstrate, Try adding
					the following metadata for the <parameter>person</parameter> object:
				</para>

				<programlisting language="java">function( toInspect, type, names ) {
		
	return {
		properties:
			name: {
				required: true
			}<symbol>,
			notes: {
				type: "string",
				large: true <co id="co-introduction-javascript-part1-layout" linkends="ca-introduction-javascript-part1-layout" />
			},
			employer: {
				type: "string",
				section: "Work"
			},
			department: {
				type: "string"
			}</symbol>
		}
	};
}</programlisting>
				
				<calloutlist>
					<callout arearefs="co-introduction-javascript-part1-layout" id="ca-introduction-javascript-part1-layout">
						<para>
							Metawidget supports a superset of JSON Schema (v3). Metadata such as <parameter>large</parameter>
							and <parameter>section</parameter> are not part of the JSON Schema specification, but are useful
							for UIs.
						</para>
					</callout>
				</calloutlist>

				<para>
					This produces the screen in <xref linkend="section-introduction-javascript-part1-screenshot4" />. Metadata
					has been added to define section headings and 'large' properties (i.e. a <parameter>textarea</parameter>).
				</para>

				<figure id="section-introduction-javascript-part1-screenshot4">
					<title>Additional properties and a section heading</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial4.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					By default,	Metawidget lays out components using an HTML <parameter>table</parameter>.
					You can configure this layout or swap it for a different one. Modify the code
					as follows:
				</para>

				<programlisting language="java">var mw = new metawidget.Metawidget( document.getElementById( 'metawidget' ), {
	
	inspector: new metawidget.inspector.CompositeInspector( [ new metawidget.inspector.PropertyTypeInspector(),
		function( toInspect, type, names ) {
				
			return {
				properties:
					name: {
						required: true
					},
					notes: {
						type: "string",
						large: true
					},
					employer: {
						type: "string",
						section: "Work"
					},
					department: {
						type: "string"
					}
				}
			};
		} ] )<symbol>,
		
	layout: new metawidget.layout.HeadingTagLayoutDecorator(
		new metawidget.layout.TableLayout( { numberOfColumns: 2 } ))</symbol>
} );</programlisting>

				<para>
					Refresh the page. The components are now arranged across two columns:
				</para>

				<figure id="section-introduction-javascript-part1-screenshot5">
					<title>A two-column layout</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial5.jpg" width="100mm" />
					</screenshot>
				</figure>

				<tip>
					<title>Note</title>
					Your browser may not have stretched the <parameter>textarea</parameter> across the full width of
					the <parameter>table</parameter>, even though the <parameter>colspan</parameter> has been set to
					4. You can add <parameter>&lt;style&gt;textarea { width: 100% }&lt;/style&gt;</parameter>
					into the <parameter>head</parameter> to confirm this visually
				</tip>

				<para>
					You may have noticed the <classname>TableLayout</classname> is nested inside
					a <classname>HeadingTagLayoutDecorator</classname>. This
					is responsible for separating widgets in different sections using <parameter>h1</parameter>
					tags. However there are other choices for separating widgets. Modify the code to
					use a JQuery UI-based <classname>TabLayoutDecorator</classname> instead:
				</para>
				
				<programlisting language="java">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;script src="lib/metawidget/core/metawidget-core.min.js" type="text/javascript"&gt;&lt;/script&gt;	
		<symbol>&lt;link rel="stylesheet" href="http://code.jquery.com/ui/1.9.2/themes/base/jquery-ui.css" /&gt;
		&lt;script src="http://code.jquery.com/jquery-1.8.3.js"&gt;&lt;/script&gt;
		&lt;script src="http://code.jquery.com/ui/1.9.2/jquery-ui.js"&gt;&lt;/script&gt;
		&lt;script src="lib/metawidget/jquery-ui/metawidget-jqueryui.min.js" type="text/javascript"&gt;&lt;/script&gt;</symbol>
		&lt;script type="text/javascript"&gt;
			var person = {
				name: "Homer Simpson",
				age: 40,
				retired: false
			};
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;form&gt;
			&lt;div id="metawidget"&gt;&lt;/div&gt;
		&lt;/form&gt;
		&lt;script type="text/javascript"&gt;
			var mw = new metawidget.Metawidget( document.getElementById( 'metawidget' ), {
				
				inspector: new metawidget.inspector.CompositeInspector( [ new metawidget.inspector.PropertyTypeInspector(),
					function( toInspect, type, names ) {
							
						return {
							properties:
								name: {
									required: true
								},
								notes: {
									type: "string",
									large: true
								},
								employer: {
									type: "string",
									section: "Work"
								},
								department: {
									type: "string"
								}
							}
						};
					} ] ),
					
				layout: new metawidget.<symbol>jqueryui.layout.TabLayoutDecorator</symbol>(
					new metawidget.layout.TableLayout( { numberOfColumns: 2 } ))
			} );		
			mw.toInspect = person;
			mw.buildWidgets();
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;</programlisting>

				<para>
					You will also need to copy <filename>js/lib/metawidget/jquery-ui/metawidget-jqueryui.min.js</filename> from
					the Metawidget binary distribution into your project.
				</para>

				<para>
					Refresh the page. The section heading is now a tab:
				</para>

				<figure id="section-introduction-javascript-part1-screenshot6">
					<title>Two-column layout with a JQuery UI tab</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial6.jpg" width="100mm" />
					</screenshot>
				</figure>
				
				<para>
					Metawidget makes it easy to apply consistent layouts across all pages of your application.
				</para>
			</section>

			<section id="section-introduction-javascript-part1-creation">
				<title>Controlling Widget Creation</title>

				<para>
					There are several ways to control widget creation. One way is to add child controls inside the
					Metawidget:
				</para>

				<programlisting language="java">&lt;form&gt;
	&lt;div id="metawidget"&gt;
		<symbol>&lt;select id="retired"&gt;
			&lt;option /&gt;
			&lt;option&gt;true&lt;/option&gt;
			&lt;option&gt;false&lt;/option&gt;
		&lt;/select&gt;</symbol>
	&lt;/div&gt;
&lt;/form&gt;</programlisting>

				<para>
					Refresh the page. The <parameter>select</parameter> box appears in place of the
					<parameter>checkbox</parameter>, because it has the same id (i.e. 'retired') as Metawidget would have given the
					<classname>checkbox</classname>. Notice Metawidget has still bound its value:
				</para>

				<figure id="section-introduction-javascript-part1-screenshot8">
					<title>The 'retired' property has been overridden</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial8.jpg" width="100mm" />
					</screenshot>
				</figure>

				<tip>
					<title>Note</title>
					The default algorithm looks for child controls with the same id, but you can plug in your own implementation
					if you need to. See <xref linkend="section-architecture-overriddenwidgetbuilder"/>.
				</tip>
				
				<para>
					To suppress a widget's creation entirely, simply supplying an empty
					<parameter>div</parameter> with id 'retired' will not work as Metawidget
					will still create an accompanying label in the left hand column. Instead, Metawidget includes special
					<parameter>stub</parameter> widgets	for this purpose:
				</para>

				<programlisting language="java">&lt;form&gt;
	&lt;div id="metawidget"&gt;
		<symbol>&lt;stub id="retired"&gt;&lt;/stub&gt;</symbol>
	&lt;/div&gt;
&lt;/form&gt;</programlisting>

				<para>
					Refresh the page. The <parameter>retired</parameter> property and its label will not appear:
				</para>

				<figure id="section-introduction-javascript-part1-screenshot9">
					<title>The 'retired' property has been suppressed</title>
					<screenshot>
						<graphic fileref="images/screenshots/js-tutorial9.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Another way is to add a <parameter>hidden</parameter> attribute to the metadata:
				</para>

				<programlisting language="java">function( toInspect, type, names ) {
	return {
		properties:
			name: {
				required: true
			},
			<symbol>retired: {
				hidden: true
			},</symbol>			
			notes: {
				type: "string",
				large: true
			},
			employer: {
				type: "string",
				section: "Work"
			},
			department: {
				type: "string"
			}
		}
	};
}</programlisting>

				<para>
					In both cases, <classname>metawidget.layout.TableLayout</classname>
					is smart enough to always give large components
					like <parameter>textarea</parameter> the full <parameter>colspan</parameter> of the
					<parameter>table</parameter>.
				</para>

			</section>

		</section>

		<section id="section-introduction-part2">
			<title>Part 2 - The Address Book Application</title>
			
			<para>
				Part 2 explores a more substantial application, and shows how Metawidget can be used to map the <emphasis>same</emphasis> back-end
				to <emphasis>multiple</emphasis> front-ends. We will develop an Address Book application with
				desktop-based, Web-based and mobile-based UIs.
			</para>
			
			<para>
				This tutorial should take around 45 minutes. Before you begin, you will need to download
				the examples distribution from
				<ulink url="http://metawidget.org/download.php">http://metawidget.org/download.php</ulink>. This includes
				pre-built example applications with full source code. To save time, we will not
				focus on any one front-end framework in detail. For detailed framework-specific instructions, please see 
				<xref linkend="chapter-metawidgets"/>.
			</para>
			
			<section id="section-introduction-part2-desktop">
				<title>Desktop Address Book</title>
				
				<para>
					The Desktop Address Book is essentially a larger version of the application developed in
					Part 1 - it just has more domain objects and more widgets.
				</para>
				
				<tip>
					<title>Note</title>
					If you are only interested in the JavaScript-based Metawidget, you should skip straight to
					<xref linkend="section-introduction-part2-web"/>.
				</tip>				

				<para>
					The application is pre-built for you in <filename>examples/swing/addressbook-swing.jar</filename>.
					This is a self-executing JAR. For convenience, it has <filename>MANIFEST.MF</filename> dependencies hard-coded into it, so
					it's best not to move it to a different folder (if you do, you'll need to
					manually fix up your <parameter>CLASSPATH</parameter>).
				</para>
				
				<tip>
					<title>Note</title>
					There is also an SWT version of the Address Book sample in <filename>examples/swt/addressbook-swt.jar</filename>. You can
					mostly replace references to 'Swing' in this section with 'SWT' and follow along using SWT if preferred. 
				</tip>				

				<para> 
					Run the code by navigating to the <filename>examples/swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar addressbook-swing.jar</programlisting>
				
				<para>
					The opening screen displays a search filter (at the top) and lists
					existing Address Book entries (at the bottom) as in
					<xref linkend="section-introduction-part2-swing-desktop-opening-screenshot"/> (Swing version) and
					<xref linkend="section-introduction-part2-swt-desktop-opening-screenshot"/> (SWT version).
				</para>
				
				<figure id="section-introduction-part2-swing-desktop-opening-screenshot">
					<title>Swing Desktop Address Book opening screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/desktop-addressbook1.jpg" width="100mm" />
					</screenshot>
				</figure>
				
				<figure id="section-introduction-part2-swt-desktop-opening-screenshot">
					<title>SWT Desktop Address Book opening screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/desktop-swt-addressbook.jpg" width="100mm" />
					</screenshot>
				</figure>
				
				<para>
					The three search filter fields (<parameter>Firstname</parameter>, <parameter>Surname</parameter> and <parameter>Type</parameter>)
					are created by <classname>SwingMetawidget</classname>
					based on the <classname>ContactSearch</classname> business class. This includes populating the <parameter>Type</parameter> dropdown based
					on the <classname>ContactType</classname>
					enum. The <guibutton>Search</guibutton>, <guibutton>Add Personal Contact</guibutton> and <guibutton>Add Business Contact</guibutton> buttons
					are created by <classname>SwingMetawidget</classname> based on annotated action methods in the <classname>ContactDialog</classname> class.
					The rest of the screen - including the images, background and layout - are managed by regular Swing code and are not controlled
					by Metawidget: Metawidget does not try to 'own' the entire UI.					
				</para>
				
				<tip>
					<title>Note</title>
					Full source code for all the examples, such as the code for the <classname>ContactSearch</classname>,
					<classname>ContactType</classname> and <classname>ContactDialog</classname> classes, is
					included under the <filename>src/examples</filename> folder of the examples distribution.
				</tip>				

				<para>
					Click <guibutton>Add Personal Contact</guibutton>. The screen displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-desktop-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-desktop-add-screenshot">
					<title>Desktop Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/desktop-addressbook2.jpg" width="100mm" />
					</screenshot>
				</figure>				

				<para>
					All the form fields are created by <classname>SwingMetawidget</classname> based on the <classname>PersonalContact</classname> business class.
					This class is itself derived from the <classname>Contact</classname> business class. It includes some Metawidget annotations
					for dropdown values and section headings.
				</para>
				
				<para>
					Note the code only has one <classname>JDialog</classname> class (<classname>ContactDialog</classname>), but is capable of supporting both
					<classname>PersonalContact</classname> and <classname>BusinessContact</classname> UIs. The fields in the UI change depending on
					the object passed to <classname>ContactDialog</classname> at runtime. This is the Third Goal Of Metawidget:
				</para>
				
				<important>
					<title>Third Goal Of Metawidget</title>			
					Metawidget can perform inspection <emphasis>at runtime</emphasis>, detecting types and subtypes dynamically				
				</important>
				
				<para>
					The <parameter>Address</parameter> property is created as a nested <classname>SwingMetawidget</classname>. This is the default behaviour when Metawidget
					encounters datatypes it does not know how to represent using any other UI widget. The <parameter>Communications</parameter> property
					has been overridden with a manually specified <classname>JTable</classname>.
				</para>
				
				<para>
					In addition, <function>JTable.setCellEditor</function> uses <classname>SwingMetawidget</classname> to render single
					<classname>JComponent</classname>s as <classname>CellEditor</classname>s. This includes automatically populating dropdown values.
				</para>
				
				<section id="section-introduction-part2-desktop-readonly">
					<title>Read-Only Mode</title>

					<para>
						The Desktop Address Book uses Metawidget's <function>setReadOnly(true)</function> method to display
						read-only screens. Return to the main screen, and double-click on an existing contact (such as
						Homer Simpson). The same <classname>ContactDialog</classname> is used, but this time
						all the widgets are read-only labels as in <xref linkend="section-introduction-part2-desktop-readonly-screenshot"/>.
					</para>
					
					<figure id="section-introduction-part2-desktop-readonly-screenshot">
						<title>Desktop Address Book read-only mode</title>
						<screenshot>
							<graphic fileref="images/screenshots/desktop-addressbook3.jpg" width="100mm" />
						</screenshot>
					</figure>

					<para>
						Click <guibutton>Edit</guibutton>. The labels are transformed into editable widgets by using
						Metawidget's <function>setReadOnly(false)</function>, as in <xref linkend="section-introduction-part2-desktop-editable-screenshot"/>.
					</para>
					
					<figure id="section-introduction-part2-desktop-editable-screenshot">
						<title>Desktop Address Book edit mode</title>
						<screenshot>
							<graphic fileref="images/screenshots/desktop-addressbook4.jpg" width="100mm" />
						</screenshot>
					</figure>
					
				</section>
				
				<section id="section-introduction-part2-desktop-binding">
					<title>Binding</title>

					<para>
						The data from the <classname>PersonalContact</classname> object is automatically inserted into the
						<classname>JComponent</classname>s. It is also automatically saved back when clicking <guibutton>Save</guibutton>.
					</para>
					
					<para>					
						Swing does not define a <classname>JComponent</classname> to <classname>Object</classname> mapping mechanism, so by default
						<classname>SwingMetawidget</classname> only supplies
						<function>setValue</function> and <function>getValue</function> methods for manually fetching values. This situation is no
						worse than a normal Swing application, but Metawidget can do better.
					</para>
				
					<para> 					
						<classname>SwingMetawidget</classname> directly supports third-party binding alternatives such as
						<ulink url="http://commons.apache.org/beanutils">Apache BeanUtils</ulink> and
						<ulink url="https://beansbinding.dev.java.net">Beans Binding (JSR 295)</ulink>
						via <function>SwingMetawidget.addWidgetProcessor</function>. These
						binding implementations automatically map <classname>JComponent</classname> values to <classname>Object</classname> values,
						including performing the necessary conversions, further reducing the amount of boilerplate code required.
					</para>
					
					<para>
						<classname>SwtMetawidget</classname> does something similar using <classname>org.eclipse.core.databinding.Binding</classname>.
					</para>				
				</section>
				
				<section id="section-introduction-part2-desktop-i18n">
					<title>Localization</title>

					<para>
						All text within the application has been localized to the <classname>org.metawidget.example.shared.addressbook.resource.Resources</classname>
						resource bundle. Text created manually (such as the buttons) uses typical Swing localization code (e.g. <function>bundle.getString</function>). Text created by
						<classname>SwingMetawidget</classname> uses <function>SwingMetawidget.setBundle</function>, which internally defers to Swing's
						<function>bundle.getString</function>.
					</para>
					
					<para>	
						Localization is very easy with Metawidget. For property names, if no resource bundle is supplied, Metawidget uses an 'uncamel-cased' version of the
						name (e.g. <parameter>dateOfBirth</parameter> becomes <parameter>Date Of Birth</parameter>).
						If a bundle <emphasis>is</emphasis> supplied, Metawidget uses the property name as the bundle key. For section headings, if a bundle is supplied,
						Metawidget uses a 'camel-cased' version of the headings as the key.
					</para>
					
					<para>
						This means developers can initially
						build their UIs without worrying about resource bundles, then turn on localization support later.
					</para>
					
				</section>
				
			</section>
			
			<section id="section-introduction-part2-web">
				<title>Web Address Book</title>
				
				<para>
					As there are a large number of Web application frameworks to choose from, this example comes written
					in nine of the most popular: AngularJS, Google Web Toolkit (GWT), Java Server Faces (JSF) 1.x and 2.x (using Facelets),
					Java Server Pages (JSP), JQuery Mobile, Spring Web MVC, Struts, Vaadin and Web Components. We recommend you follow along
					using the one most relevant to you.
				</para>
				
				<para>
					Web-based applications are inherently more difficult to setup and run than desktop-based
					applications because they require a server (this is true even for the pure client-side, JavaScript-based
					versions of the Address Book as they make REST calls).
					For this tutorial we recommend using Apache Tomcat as it is one of the easier containers
					to get running (the examples are tested against Tomcat <?eval ${tomcatVersion}?>).
					Tomcat can be downloaded from <ulink url="http://tomcat.apache.org">http://tomcat.apache.org</ulink>.
				</para>
				
				<para>
					Take a fresh install of Tomcat. The Address Book application is pre-built for you in
					either <filename>examples/js/angular/addressbook</filename>,
					<filename>examples/js/jquery/mobile/addressbook</filename>,
					<filename>examples/js/webcomponent/addressbook</filename>,
					<filename>examples/java/faces/addressbook-faces.war</filename>, <filename>examples/java/gwt/addressbook-gwt.war</filename>,
					<filename>examples/java/jsp/addressbook-jsp.war</filename>, <filename>examples/java/spring/addressbook-spring.war</filename>,
					<filename>examples/java/struts/addressbook-struts.war</filename> or <filename>examples/java/vaadin/addressbook-struts.war</filename>.
					Alternatively you can build it yourself
					by changing to the <filename>src/examples</filename> folder and typing:
				</para>
				
				<programlisting language="shell">mvn -pl org.metawidget.examples.faces:addressbook-faces -am integration-test</programlisting>

				<para>
					(replacing <parameter>faces</parameter> with <parameter>gwt</parameter>, <parameter>jsp</parameter>, <parameter>spring</parameter>,
					<parameter>struts</parameter> or <parameter>vaadin</parameter> as appropriate).
				</para>

				<tip>
					<title>Note</title>
					For most web environments, deploying Metawidget is as simple as adding <filename>metawidget-all.jar</filename> to
					<filename>WEB-INF/lib</filename> or <filename>metawidget-core.min.js</filename> to <filename>lib/metawidget</filename>.
					For GWT, you'll also need to include <filename>metawidget-all.jar</filename>
					and <filename>additional/gwt/metawidget-all-sources.jar</filename> in the <parameter>CLASSPATH</parameter>
					during your <parameter>GWTCompiler</parameter> step.
				</tip>				

				<para>
					Copy the application into Tomcat's <filename>webapps</filename> folder, start Tomcat, and open a Web browser
					to <ulink url="http://localhost:8080/addressbook-faces">http://localhost:8080/addressbook-faces</ulink>. The home page displays
					a search filter (at the top) and lists existing Address Book entries (at the bottom)
					as in <xref linkend="section-introduction-part2-web-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-web-opening-screenshot">
					<title>Web Address Book opening screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-addressbook1.jpg" width="100mm" />
					</screenshot>
				</figure>

				<figure id="section-introduction-part2-web-opening-screenshot-jquerymobile">
					<title>Web Address Book opening screen (JQuery Mobile version)</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-addressbook-jquerymobile.jpg" width="50mm" />
					</screenshot>
				</figure>

				<para>
					As with the Desktop Address Book, the search filter fields are created
					by Metawidget (this time <classname>AngularMetawidget</classname>, <classname>UIMetawidget</classname>,
					<classname>GwtMetawidget</classname>, <classname>HtmlMetawidgetTag</classname>,					
					<classname>JQueryMobileMetawidget</classname>, <classname>SpringMetawidgetTag</classname>, <classname>StrutsMetawidgetTag</classname>
					or <classname>VaadinMetawidget</classname>) based on the <classname>ContactSearch</classname> business class:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.search}"&gt;
	...
&lt;/m:metawidget&gt;</programlisting>
				
				<para>
 					Again, this includes populating the <parameter>Type</parameter> dropdown and localizing the text. The <guibutton>Search</guibutton>,
					<guibutton>Add Personal Contact</guibutton> and <guibutton>Add Business Contact</guibutton> buttons are either manually specified
					in the JSP page (for GWT, Spring and Struts) or created by <classname>UIMetawidget</classname> based on annotated methods
					in the <classname>ContactBean</classname> (for JSF).
				</para>
					
				<tip>
					<title>Note</title>
					As with the Desktop Address Book, full source code for the examples can be found
					under <filename>src/examples</filename>.
				</tip>				

				<para>
					The look of the Web page relies entirely on HTML and CSS technologies. The CSS classes to
					use are configured in <filename>metawidget.xml</filename>
					(or <filename>services.js</filename> for AngularJS):
				</para>

				<programlisting language="xml">&lt;htmlMetawidget&gt;
&lt;parameter&gt;
	&lt;string&gt;tableStyleClass&lt;/string&gt;
	&lt;string&gt;table-form&lt;/string&gt;
&lt;/parameter&gt;
&lt;parameter&gt;
	&lt;string&gt;columnClasses&lt;/string&gt;
	&lt;string&gt;table-label-column,table-component-column,table-required-column&lt;/string&gt;
&lt;/parameter&gt;
...</programlisting>
	
				<para>
					Only the layout	of 'one column for the label, one column for the widget' is dictated by Metawidget, and that is again
					pluggable and configurable.
				</para>
				
				<para>
					Click <guibutton>Add Personal Contact</guibutton>. The page displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-web-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-web-add-screenshot">
					<title>Web Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-addressbook2.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					All the form fields are created by Metawidget based on the <classname>PersonalContact</classname> business class. The section headings
					are the same, but have this time been rendered as HTML.
				</para>
				
				<para>
					The <parameter>Address</parameter> property is a nested Metawidget. The <parameter>Communications</parameter> property
					has been overridden in the page with a manually specified table. <classname>UIMetawidget</classname> understands a manually-specified widget to
					override an automatic one if it has the same <parameter>value</parameter> binding as the automatic
					widget would have (<classname>AngularMetawidget</classname>, <classname>GwtMetawidget</classname>, <classname>SpringMetawidgetTag</classname>,
					<classname>StrutsMetawidgetTag</classname>
					and <classname>VaadinMetawidget</classname> do something similar):
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.current}"&gt;
	...		
	&lt;h:dataTable value="#{contact.current.communications}"&gt;
		...
	&lt;/h:dataTable&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>
				
				<para>
					JSF has built-in support for executing actions on table rows. In order to use it, however, the <classname>Set</classname>
					returned by <function>Contact.getCommunications</function> must be wrapped into a <classname>DataModel</classname>. This is handled by
					<function>ContactController.getCurrentCommunications</function>, but this presents a problem: the mapping for the
					<classname>HtmlDataTable</classname> must be <parameter>#{contact.currentCommunications}</parameter>, but the mapping required to override
					<classname>UIMetawidget</classname>'s automatic widget creation is <parameter>#{contact.current.communications}</parameter>.
				</para>
				
				<para>
					<classname>UIMetawidget</classname> supplies <classname>UIStub</classname> for these situations. Stubs have a binding, but do nothing with it
					and render nothing. They can be used either to suppress widget creation entirely (a stub
					with an empty body) or to replace the automatic widget creation with one or more other widgets
					with different bindings:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget value="#{contact.current}"&gt;
	...		
	&lt;m:stub value="#{contact.current.communications}"&gt;
		&lt;h:dataTable value="#{contact.currentCommunications}"&gt;
			...
		&lt;/h:dataTable&gt;						
	&lt;/m:stub&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>

				<para>
					JSP, Spring, Struts lack some component-based features found in Swing and JSF. Specifically,
					whilst it is possible for tags to reference their <emphasis>parent</emphasis>
					(using <function>TagSupport.findAncestorWithClass</function>), they have no way to interrogate
					their <emphasis>children</emphasis>. Therefore, it is not possible to directly support arbitrary child tags
					within <classname>HtmlMetawidget</classname>, <classname>SpringMetawidgetTag</classname> and <classname>StrutsMetawidgetTag</classname>.
				</para>

				<para>
					Instead, we wrap the overridden <parameter>Communications</parameter> property in Metawidget's <classname>Stub</classname> tag. Metawidget
					and its Stub tags have explicit	support for co-ordinating the overriding of widget creation:
				</para>
				
				<programlisting language="jsp">&lt;m:metawidget property="contactForm"&gt;
	...		
	&lt;m:stub property="communications"&gt;
		&lt;table class="data-table"&gt;
			...
		&lt;/table&gt;
	&lt;/m:stub&gt;						
	...							
&lt;m:metawidget&gt;</programlisting>

				<para>
					<classname>GwtMetawidget</classname> uses stubs around GWT widgets like <classname>FlexTable</classname>, but can use
					the overriding widget directly if it supports the <classname>HasName</classname> interface (e.g. TextBox, CheckBox, etc)
					and has a name matching the name of the domain object property.
				</para>

				<section id="section-introduction-part2-web-mixing">
					<title>Mixing Metawidgets</title>
					
					<para>
						The section is specific to Spring/Struts.
					</para>

					<para>
						Within the <parameter>Communications</parameter> table, implementing <guibutton>Add Communication</guibutton> calls for a design decision.
						Struts does not support multiple <classname>ActionForm</classname>s per <classname>Action</classname>, so we are unable to combine
						<classname>PersonalContactForm</classname> with a <classname>CommunicationForm</classname> (as we did in the JSF). Spring has a similar
						limitation of not supporting multiple <parameter>commandNames</parameter> per form. Instead, we need to either:
					</para>
					
					<itemizedlist>
						<listitem>
							<para>
								add properties from <classname>Communication</classname> to <classname>PersonalContactForm</classname>, and ignore them when
								saving the <classname>PersonalContact</classname>; or
							</para>
						</listitem>
						<listitem>
							<para>
						 		output plain HTML tags (i.e. independent of Spring and Struts) and handle them manually
						 	</para>
						 </listitem>
					</itemizedlist>
					
					<para>
						Both approaches would be valid. For this tutorial, we choose the latter as it allows us to introduce <classname>HtmlMetawidget</classname>
						(a Metawidget for plain HTML/JSP webapps that don't use Struts or Spring) and demonstrate <emphasis>mixing</emphasis> two Metawidgets on
						the same page:
					</para>
	
					<programlisting language="jsp"><symbol>&lt;m:metawidget property="contactForm"&gt;</symbol>
	...
	&lt;m:stub property="communications"&gt;
		&lt;table class="data-table"&gt;
		...
		&lt;tr&gt;
			&lt;jsp:useBean id="communication"
							class="org.metawidget.example.shared.addressbook.model.Communication"/&gt;		
			&lt;td&gt;<symbol>&lt;mh:metawidget value="communication.type" style="width: 100%" /&gt;</symbol>&lt;/td&gt;
			&lt;td&gt;<symbol>&lt;mh:metawidget value="communication.value" style="width: 100%" /&gt;</symbol>&lt;/td&gt;
		&lt;/tr&gt;
		...
		&lt;/table&gt;
	&lt;/m:stub&gt;
	...
<symbol>&lt;/m:metawidget&gt;</symbol></programlisting>
	
					<para>
						The two different tag prefixes <parameter>m:</parameter> and <parameter>mh:</parameter> denote different tag libraries. 
						<classname>HtmlMetawidget</classname> is very similiar to <classname>StrutsMetawidgetTag</classname>, but has to use
						<parameter>jsp:useBean</parameter> to manually instantiate the bean (rather than letting Struts do it). 
						Within <filename>metawidget.xml</filename>, the default <classname>Layout</classname> for <classname>HtmlMetawidget</classname> has been
						set to <classname>org.metawidget.jsp.tagext.layout.SimpleLayout</classname> (i.e. a plain layout, without a label column)
					</para>
					
				</section>				
				
				<section id="section-introduction-part2-web-expression-lookup">
					<title>Expression Based Lookups</title>
					
					<para>
						This section does not apply to GWT.
					</para>

					<para>
						In the Desktop Address Book, the <parameter>title</parameter> dropdown was populated by
						a static <parameter>lookup</parameter> attribute in <filename>metawidget-metadata.xml</filename>. JSP and JSF-based technologies can do better, because they have a built-in
						scope-based component model and Expression Language.
					</para>
					
					<para>
						<function>Contact.getTitle</function> is annotated
						using <classname>@UiFacesLookup</classname> and <classname>@UiSpringLookup</classname> (and <function>ContactForm.getTitle</function>
						is annotated using <classname>@UiStrutsLookup</classname>). These are used at runtime to create dynamic lookups.
					</para>
					
					<para>
						These annotations, unlike the ones we have used so far, <emphasis>are</emphasis> UI-framework specific so you may prefer
						to declare them in <filename>metawidget-metadata.xml</filename>. Before doing so, however, you should understand we are still
						not introducing runtime dependencies into our business classes: an important feature of annotations is they 'fall away gracefully'
						if their implementing class is not found. Annotations never throw <classname>ClassDefNotFoundError</classname>.
					</para>
					
				</section>

				<section id="section-introduction-part2-web-richfaces">
					<title>Alternate Widget Libraries (JSF 1.x)</title>
					
					<para>
						This section is specific to JSF 1.x.
					</para>
					
					<para>
						Metawidget factors all widget creation into <classname>WidgetBuilder</classname>s. Like <classname>Inspector</classname>s, multiple
						<classname>WidgetBuilder</classname>s can be combined using a <classname>CompositeWidgetBuilder</classname> to support third-party component
						libraries. In this section we will override Metawidget's default and introduce a <classname>RichFacesWidgetBuilder</classname>
						alongside the standard JSF <classname>HtmlWidgetBuilder</classname>. 
					</para>
					
					<para>
						Go into Tomcat's <filename>webapps/addressbook-faces</filename> folder (the exploded WAR) and
						edit <filename>WEB-INF/metawidget.xml</filename>:
					</para>
					
					<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

&lt;htmlMetawidget xmlns="java:org.metawidget.faces.component.html"&gt;
	...
	&lt;inspector&gt;		
		&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
								config="CompositeInspectorConfig"&gt;
			&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
				&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation"/&gt;
				&lt;facesAnnotationInspector xmlns="java:org.metawidget.inspector.faces"/&gt;			
				&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml" config="XmlInspectorConfig"/&gt;
			&lt;/array&gt;
			&lt;/inspectors&gt;
		&lt;/compositeInspector&gt;
	&lt;/inspector&gt;
	<symbol>&lt;widgetBuilder&gt;
		&lt;compositeWidgetBuilder xmlns="java:org.metawidget.widgetbuilder.composite"
			config="CompositeWidgetBuilderConfig"&gt;
			&lt;widgetBuilders&gt;
				&lt;array&gt;
					&lt;overriddenWidgetBuilder xmlns="java:org.metawidget.faces.component.widgetbuilder"/&gt;
					&lt;readOnlyWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
					&lt;richFacesWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder.richfaces"/&gt;
					&lt;htmlWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
				&lt;/array&gt;
			&lt;/widgetBuilders&gt;
		&lt;/compositeWidgetBuilder&gt;
	&lt;/widgetBuilder&gt;</symbol>
	&lt;layout&gt;
		&lt;outputTextLayoutDecorator xmlns="java:org.metawidget.faces.component.html.layout"
			config="OutputTextLayoutDecoratorConfig"&gt;
			&lt;layout&gt;
				&lt;simpleLayout xmlns="java:org.metawidget.faces.component.layout"/&gt;
			&lt;/layout&gt;
			&lt;styleClass&gt;
				&lt;string&gt;section-heading&lt;/string&gt;
			&lt;/styleClass&gt;
		&lt;/outputTextLayoutDecorator&gt;
	&lt;/layout&gt;	
&lt;/htmlMetawidget&gt;

&lt;/metawidget&gt;</programlisting>
	
					<para>
						Now restart Tomcat, refresh your Web browser and click on Homer Simpson. Notice how the
						<parameter>Date of Birth</parameter> field for Personal Contacts is now a RichFaces date picker
						widget, and the <parameter>Number of Staff</parameter> field for Business Contacts is a RichFaces slider widget.
					</para>
					
					<para>
						Going futher, Metawidget's pluggable layouts make it easy to support third-party layout components.
						Edit <filename>WEB-INF/metawidget.xml</filename> again:
					</para>
					
					<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

&lt;htmlMetawidget xmlns="java:org.metawidget.faces.component.html"&gt;
	...
	&lt;inspector&gt;		
		&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
								config="CompositeInspectorConfig"&gt;
			&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
				&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation"/&gt;
				&lt;facesAnnotationInspector xmlns="java:org.metawidget.inspector.faces"/&gt;			
				&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml" config="XmlInspectorConfig"/&gt;
			&lt;/array&gt;
			&lt;/inspectors&gt;
		&lt;/compositeInspector&gt;
	&lt;/inspector&gt;
	&lt;widgetBuilder&gt;
		&lt;compositeWidgetBuilder xmlns="java:org.metawidget.widgetbuilder.composite"
			config="CompositeWidgetBuilderConfig"&gt;
			&lt;widgetBuilders&gt;
				&lt;array&gt;
					&lt;overriddenWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
					&lt;readOnlyWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
					&lt;richFacesWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder.richfaces"/&gt;
					&lt;htmlWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
				&lt;/array&gt;
			&lt;/widgetBuilders&gt;
		&lt;/compositeWidgetBuilder&gt;
	&lt;/widgetBuilder&gt;
	&lt;layout&gt;
		<symbol>&lt;tabPanelLayoutDecorator xmlns="java:org.metawidget.faces.component.html.layout.richfaces"
			config="TabPanelLayoutDecoratorConfig"&gt;</symbol>
			&lt;layout&gt;
				&lt;simpleLayout xmlns="java:org.metawidget.faces.component.layout"/&gt;
			&lt;/layout&gt;
		<symbol>&lt;/tabPanelLayoutDecorator&gt;</symbol>
	&lt;/layout&gt;	
&lt;/htmlMetawidget&gt;

&lt;/metawidget&gt;</programlisting>

					<para>
						Restart Tomcat, refresh your Web browser and click on Homer Simpson again. Notice how the
						<parameter>Contact Details</parameter> and <parameter>Other</parameter> sections are
						laid out as tabs within a RichFaces <classname>TabPanel</classname> as in
						<xref linkend="section-introduction-part2-web-richfaces-screenshot"/>.						
					</para>

					<figure id="section-introduction-part2-web-richfaces-screenshot">
						<title>Web Address Book using JBoss RichFaces</title>
						<screenshot>
							<graphic fileref="images/screenshots/web-addressbook-richfaces.jpg" width="100mm" />
						</screenshot>
					</figure>

					<para>
						This demonstrates how easy it is to leverage widget libraries with Metawidget
						(this example cheats a bit, as we've pre-added the RichFaces JARs into <filename>WEB-INF/lib</filename> and some
						lines into <filename>web.xml</filename>, but you get the idea).					
					</para>
					
				</section>

				<section id="section-introduction-part2-web-primefaces">
					<title>Alternate Widget Libraries (JSF 2.x)</title>
					
					<para>
						This section is specific to JSF 2.x.
					</para>
					
					<para>
						As in the previous section, we can override Metawidget's default and introduce an alternate <classname>WidgetBuilder</classname>
						alongside the standard JSF <classname>HtmlWidgetBuilder</classname>. This time we will demonstrate using PrimeFaces. 
					</para>
					
					<para>
						Go into Tomcat's <filename>webapps/addressbook-faces2</filename> folder (the exploded WAR) and
						edit <filename>WEB-INF/metawidget.xml</filename>:
					</para>
					
					<programlisting language="xml">&lt;metawidget xmlns="http://metawidget.org"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	version="1.0"
	xsi:schemaLocation="http://metawidget.org http://metawidget.org/xsd/metawidget-1.0.xsd"&gt;

&lt;htmlMetawidget xmlns="java:org.metawidget.faces.component.html"&gt;
	...
	&lt;inspector&gt;		
		&lt;compositeInspector xmlns="java:org.metawidget.inspector.composite"
								config="CompositeInspectorConfig"&gt;
			&lt;inspectors&gt;
			&lt;array&gt;
				&lt;propertyTypeInspector xmlns="java:org.metawidget.inspector.propertytype"/&gt;
				&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation"/&gt;
				&lt;facesAnnotationInspector xmlns="java:org.metawidget.inspector.faces"/&gt;			
				&lt;xmlInspector xmlns="java:org.metawidget.inspector.xml" config="XmlInspectorConfig"/&gt;
			&lt;/array&gt;
			&lt;/inspectors&gt;
		&lt;/compositeInspector&gt;
	&lt;/inspector&gt;
	<symbol>&lt;widgetBuilder&gt;
		&lt;compositeWidgetBuilder xmlns="java:org.metawidget.widgetbuilder.composite"
			config="CompositeWidgetBuilderConfig"&gt;
			&lt;widgetBuilders&gt;
				&lt;array&gt;
					&lt;overriddenWidgetBuilder xmlns="java:org.metawidget.faces.component.widgetbuilder"/&gt;
					&lt;readOnlyWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
					&lt;primeFacesWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder.primefaces"/&gt;
					&lt;htmlWidgetBuilder xmlns="java:org.metawidget.faces.component.html.widgetbuilder"/&gt;
				&lt;/array&gt;
			&lt;/widgetBuilders&gt;
		&lt;/compositeWidgetBuilder&gt;
	&lt;/widgetBuilder&gt;</symbol>
	&lt;layout&gt;
		<symbol>&lt;tabViewLayoutDecorator xmlns="java:org.metawidget.faces.component.html.layout.primefaces"
			config="org.metawidget.layout.decorator.LayoutDecoratorConfig"&gt;</symbol>
			&lt;layout&gt;
				&lt;simpleLayout xmlns="java:org.metawidget.faces.component.layout"/&gt;
			&lt;/layout&gt;
		<symbol>&lt;/tabViewLayoutDecorator&gt;</symbol>
	&lt;/layout&gt;	
&lt;/htmlMetawidget&gt;

&lt;/metawidget&gt;</programlisting>

					<para>
						Restart Tomcat, refresh your Web browser and click on Charles Montgomery Burns. Notice how the
						<parameter>Contact Details</parameter> and <parameter>Other</parameter> sections are
						laid out as tabs within a PrimeFaces <classname>TabView</classname> and the <parameter>Number of Staff</parameter>
						field is a PrimeFaces <classname>Slider</classname>. See <xref linkend="section-introduction-part2-web-primefaces-screenshot"/>.
					</para>

					<figure id="section-introduction-part2-web-primefaces-screenshot">
						<title>Web Address Book using PrimeFaces</title>
						<screenshot>
							<graphic fileref="images/screenshots/web-addressbook-primefaces.jpg" width="100mm" />
						</screenshot>
					</figure>

					<para>
						This demonstrates how easy it is to leverage widget libraries with Metawidget
						(this example cheats a bit, as we've pre-added the PrimeFaces JARs into <filename>WEB-INF/lib</filename> and some
						lines into <filename>web.xml</filename>, but you get the idea).					
					</para>
					
				</section>

			</section>

			<section id="section-introduction-part2-mobile">
				<title>Mobile Address Book</title>
				
				<para>
					For the Mobile Address Book we use the Android platform. Like Web-based applications, mobile applications require a container to run.
					If you have a physical Android device you can install the Mobile Address Book by downloading and opening
					<ulink url="http://metawidget.org/examples/android/addressbook-android.apk">http://metawidget.org/examples/android/addressbook-android.apk</ulink>
					or scanning this QR Code:
				</para>
				
				<figure id="section-introduction-part2-mobile-qrcode">
					<title>Mobile Address Book APK URL</title>
					<screenshot>
						<graphic fileref="images/screenshots/mobile-qrcode.png" width="30mm" />
					</screenshot>
				</figure>
				
				<tip>
					<title>Note</title>
					The Android Address Book is a native mobile application. For an example of an HTML 5
					hybrid mobile application see the JQuery Mobile Address Book in the previous section.
				</tip>				

				<para>
					Alternatively download the Android SDK
					from <ulink url="http://code.google.com/android/download.html">http://code.google.com/android/download.html</ulink>
					(the examples are tested against Android 1.1).
					Then change to the installation directory (usually defined by <parameter>ANDROID_HOME</parameter>) and run the emulator by
					opening a command prompt and typing:
				</para>
				
				<programlisting language="shell">tools\android create avd -n my_avd -t 1</programlisting>
				
				<para>
					Replacing <parameter>-t 1</parameter> with the Android version you're using (e.g. <parameter>-t 2</parameter> for
					1.5, <parameter>-t 3</parameter> for 1.6, <parameter>-t 4</parameter> for 2.0). Android 1.1 doesn't use AVDs, so you can skip
					this step. Next type:
				</para>
				
				<programlisting language="shell">tools\emulator -avd my_avd</programlisting>
				
				<para>
					The emulator may take a little while to start. Once finished, it will display the phone's desktop. The Address Book APK
					is pre-built for you in <filename>examples/android/addressbook-android.apk</filename>. Alternatively you
					can build it yourself by changing to the <filename>src/examples</filename> folder and typing:
				</para>
				
				<programlisting language="shell">mvn -pl org.metawidget.examples.android:addressbook-android -am integration-test</programlisting>

				<para>				
					Next, open a <emphasis>second</emphasis> command prompt, change to the Android installation directory and type:
				</para>
				
				<programlisting language="shell">platform-tools\adb install &lt;metawidget folder&gt;\examples\android\addressbook-android.apk</programlisting>
				
				<para>
					This deploys the APK into the emulator. To run it, click the emulator's <parameter>Menu</parameter> button and
					then choose the Address Book application. The emulator displays a search filter (at the top) and lists existing
					Address Book entries (at the bottom) as in <xref linkend="section-introduction-part2-mobile-opening-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-opening-screenshot">
					<title>Mobile Address Book opening screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/mobile-addressbook1.jpg" width="60mm" />
					</screenshot>
				</figure>

				<para>
					As with the Desktop and Web Address Books, the three search filter fields are created
					by Metawidget (this time <classname>AndroidMetawidget</classname>) based on the <classname>ContactSearch</classname> business class.
					Again, this includes populating the <parameter>Type</parameter> dropdown.
				</para>

				<tip>
					<title>Note</title>
					As with the Desktop Address Book, full source code for the examples can be found
					under <filename>src/examples</filename>. To open it in Eclipse we recommend installing
					<ulink url="http://marketplace.eclipse.org/content/maven-integration-android-development-tools">Maven Integration for Android Development Tools</ulink>.
				</tip>				

				<para>
					The look of the screen relies entirely on Android XML layout files, styles and themes. Only the 'one column for the label, one column
					for the widget' layout is dictated by Metawidget, and that is pluggable and configurable.
				</para>

				<para>
					Choose <guibutton>Add Personal</guibutton> from the Android menu. The page displays a form for filling out Personal Contact information
					as in <xref linkend="section-introduction-part2-mobile-add-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-add-screenshot">
					<title>Mobile Address Book 'Add Personal Contact' screen</title>
					<screenshot>
						<graphic fileref="images/screenshots/mobile-addressbook2.jpg" width="60mm" />
					</screenshot>
				</figure>

				<para>
					UIs in Android are typically defined using XML layout files, though they can also be built programmatically.
					<classname>AndroidMetawidget</classname> supports both approaches. For example, the Personal Contact screen is
					defined in <filename>contact.xml</filename>, and contains a Metawidget defined in much the same way as in
					JSP (including configuring section style and overriding widget creation): 
				</para>

				<programlisting language="xml">&lt;view class="org.metawidget.android.widget.AndroidMetawidget" android:id="@+id/metawidget"
	config="@raw/metawidget"&gt;
	
	&lt;view class="org.metawidget.android.widget.Stub" tag="communications"&gt;
			
		&lt;ListView android:id="@id+/communications" ... /&gt;
	 			
		&lt;Button android:id="@+id/buttonAddCommunication"
			android:text="@string/addCommunication" ... /&gt;
	
	&lt;/view&gt;
 
&lt;/view&gt;</programlisting>
				
				<para>
					Within <classname>CommunicationDialog</classname>, a Metawidget is defined programatically in much the same way as in
					Swing:
				</para>
				
				<programlisting language="java">mMetawidget = new AndroidMetawidget( activity );
mMetawidget.setConfig( R.raw.config );				
...
mMetawidget.setToInspect( mCommunication );</programlisting>
				
				<para>
					This produces the dialog box in <xref linkend="section-introduction-part2-mobile-dialog-screenshot"/>.
				</para>
				
				<figure id="section-introduction-part2-mobile-dialog-screenshot">
					<title>Mobile Address Book Communications Dialog</title>
					<screenshot>
						<graphic fileref="images/screenshots/mobile-addressbook3.jpg" width="60mm" />
					</screenshot>
				</figure>

			</section>

			<section>
				<title>Conclusion</title>
				
				<para>
					That concludes the introductory tutorial. In summary, we have now:
				</para>
	
				<itemizedlist>
					<listitem>
						<para>
							seen how to build an application whose UI is largely dictated by its business classes, not by hand-written UI code
						</para>
					</listitem>
					<listitem>
						<para>
							significantly reduced the amount of UI code needed in our applications
						</para>
					</listitem>
					<listitem>
						<para>
							seen how to build an application that targets multiple platforms. If we were to add a new property to one of the business classes
							(say, <parameter>numberOfChildren</parameter> to <classname>PersonalContact</classname>), it would automatically appear
							and be functional on every platform.
						</para>
					</listitem>
				</itemizedlist>
			</section>

		</section>
			
		<section id="section-introduction-part3-other-examples">
			<title>Part 3 - Other Examples</title>
			
			<para>
				The Metawidget distribution includes other examples showcasing particular features
				on particular platforms. These additional examples are not a required part of the tutorial,
				but you may find them useful depending on which platform you use.
			</para>
	
			<section id="section-introduction-part3-applet">
				<title>Swing Applet Address Book Example</title>
	
				<para>
					The Swing Applet Address Book Example demonstrates using Metawidget in applets. The example is pre-built for you in
					<filename>examples/swing/applet/addressbook</filename>. Alternatively you can build it
					yourself by changing to the <filename>src/examples</filename> folder and typing:
				</para>

				<programlisting language="shell">mvn -pl org.metawidget.examples.swing:addressbook-swing-applet -am integration-test</programlisting>
				
				<para>
					To run the applet, open the <filename>index.html</filename> file in a Web browser. The code
					is identical to the Swing Address Book covered in Part 2 of this tutorial, except
					it uses <classname>org.metawidget.example.swing.applet.AddressBookApplet</classname> instead
					of <classname>org.metawidget.example.swing.addressbook.MainFrame</classname>.
				</para>

				<para>
					The notable feature of the example is how the applet is packaged. Metawidget is highly modular and has no
					mandatory third-party JAR dependencies. The <filename>addressbook-swing-applet</filename> Maven POM
					uses fine-grained Metawidget dependencies (as an alternative to <filename>metawidge-all.jar</filename>)
					to include only those modules necessary for the applet. The resulting small download size
					makes Metawidget very viable for applet-based environments. See
					<xref linkend="section-howto-performance-jar"/>.
				</para>
	
			</section>
			
			<section id="section-introduction-part3-seam">
				<title>Seam Example</title>
	
				<para>
					The Seam Booking Example demonstrates updating an existing Seam application to use Metawidget, reducing
					boilerplate code. The example is included as part of <ulink url="http://seamframework.org/Download">Seam 2.2.0.GA</ulink>.
					It also requires you to have <ulink url="http://jboss.org/jbossas/downloads">JBoss 5.1.0.GA</ulink>,
					and you should be <ulink url="http://docs.jboss.com/seam/latest/reference/en-US/html/tutorial.html">familiar with the existing Seam Booking application</ulink>.
				</para>
				
				<para>
					The example is located in <filename>jboss-seam-2.2.0.GA/examples/metawidget/booking</filename>. It is
					not pre-built. To build it, change to the <filename>examples/metawidget/booking</filename> folder in
					the Seam binary distribution and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-5.1.0.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <ulink url="http://localhost:8080/seam-booking">http://localhost:8080/seam-booking</ulink>. The updated Metawidget
					Seam Booking Example looks very similar to the original, as in <xref linkend="section-introduction-part3-seam-screenshot"/>,
					but uses significantly less boilerplate code.
				</para>
				
				<figure id="section-introduction-part3-seam-screenshot">
					<title>Seam Booking with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-seam-booking.jpg" width="100mm" />
					</screenshot>
				</figure>
								
				<para>
					The files modified for adding Metawidget support are in <filename>examples/metawidget/booking</filename>. Most of the
					UI code in <filename>view/book.xhtml</filename>, <filename>view/confirm.xhtml</filename> and
					<filename>view/hotelview.xhtml</filename> has been replaced with a single Metawidget tag. Some annotations
					have been added to <filename>Hotel.java</filename> and <filename>Booking.java</filename>, though
					Metawidget also leverages the existing JPA and Hibernate Validator ones.
				</para>
				
			</section>

			<section id="section-introduction-part3-groovy">
				<title>Groovy Example</title>

				<para>
					The Seam Groovy Booking Example demonstrates updating an existing Seam Groovy application to 
					use Metawidget, reducing boilerplate code. The example is a more advanced version of the previous Seam section, so you
					should work through that first.
				</para>

				<para>
					The example is located in <filename>jboss-seam-2.2.0.GA/examples/metawidget/groovybooking</filename>. It is
					not pre-built. To build it, change to the <filename>examples/metawidget/groovybooking</filename> folder in
					the Seam distribution and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-5.1.0.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <ulink url="http://localhost:8080/jboss-seam-groovybooking">http://localhost:8080/jboss-seam-groovybooking</ulink>. As with the previous
					section, the updated Metawidget Seam Groovy Booking Example looks very similar to the original, but
					uses significantly less	boilerplate code. This time we are using Groovy to define
					our business classes. The biggest impact this has is in <filename>metawidget.xml</filename>,
					where the <classname>Inspector</classname>s have been configured to use a Groovy property style instead of a JavaBean
					property style.
				</para>
				
				<para>
					Metawidget supports pluggable 'property styles' for JavaBean, Groovy and other property styles.
					Groovy properties differ from JavaBean properties in that their annotations are tied to
					the private field, rather than the getters and setters. The use of Groovy is configured
					per <classname>Inspector</classname>, as in <filename>examples/metawidget/groovybooking/resources/WEB-INF/metawidget.xml</filename>:
				</para>

				<programlisting language="xml">&lt;propertyTypeInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;propertyStyle&gt;
		&lt;groovyPropertyStyle xmlns="java:org.metawidget.inspector.impl.propertystyle.groovy"/&gt;
	&lt;/propertyStyle&gt;
&lt;/propertyTypeInspector&gt;</programlisting>

				<para>
					The example demonstrates how Metawidget can significantly reduce the amount of boilerplate code
					in your UI layer - in some cases up to 70%.
					<xref linkend="section-introduction-part3-seam-screenshot"/> shows the <filename>book.xhtml</filename> page before and
					after being fitted with Metawidget. The red boxes and lines highlight the chunks of boilerplate
					that have been removed:
				</para>

				<figure id="section-introduction-part3-seam-groovy-screenshot">
					<title>book.xhtml before and after being fitted with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-seam-groovy.gif" width="175mm" />
					</screenshot>
				</figure>
				
			</section>
			
			<section id="section-introduction-part3-jbpm">
				<title>jBPM Example</title>
		
				<para>
					The Seam DVD Store Example demonstrates updating an existing Seam jBPM application to use Metawidget, reducing
					boilerplate code. The example requires you to have previously downloaded Seam 2.2.0.GA
					and JBoss 5.1.0.GA, and you should be familiar with the existing Seam DVD Store application.
				</para>

				<para>
					The example is located in <filename>jboss-seam-2.2.0.GA/examples/metawidget/dvdstore</filename>. It is
					not pre-built. To build it, change to the <filename>examples/metawidget/dvdstore</filename> folder in
					the Seam distribution and type:
				</para>
				
				<programlisting language="shell">ant</programlisting>

				<para>
					To run it, type:
				</para>

				<programlisting language="shell">cd \Applications\jboss-5.1.0.GA
bin\run</programlisting>

				<para>
					Open a Web browser to <ulink url="http://localhost:8080/seam-dvdstore">http://localhost:8080/seam-dvdstore</ulink>. As with the previous
					two sections, the updated Metawidget Seam DVD Store example looks very similar to the original, 
					as in <xref linkend="section-introduction-part3-jbpm-screenshot"/>, but
					uses significantly less	boilerplate code.
				</para>
				
				<figure id="section-introduction-part3-jbpm-screenshot">
					<title>Seam DVD Store with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-seam-dvd.jpg" width="100mm" />
					</screenshot>
				</figure>
				
				<para>
 					This time, as well as generating <classname>UIComponent</classname>s
					for domain objects such as <classname>com.jboss.dvd.seam.Customer</classname>, Metawidget inspects jBPM
					pageflow files like
					<filename>newuser.jpdl.xml</filename> and <filename>checkout.jpdl.xml</filename> to generate the
					correct <classname>UICommand</classname> buttons for each screen.				
				</para>

			</section>
			
			<section id="section-introduction-part3-icefaces">
				<title>ICEfaces Example</title>
	
				<para>
					<ulink url="http://icefaces.org">ICEfaces</ulink> is an AJAX component library for Java Server Faces. This example
					showcases how Metawidget can work with ICEfaces (1.8.2 and above) to deliver rich AJAX applications.
				</para>

				<para>
					The example is pre-built for you in <filename>examples/faces/penguincolony-faces.war</filename>. Copy the WAR into
					Tomcat's <filename>webapps</filename> folder, start Tomcat, and open a Web browser
					to <ulink url="http://localhost:8080/penguincolony-faces">http://localhost:8080/penguincolony-faces</ulink>:
				</para>

				<figure id="section-introduction-part3-icefaces-screenshot">
					<title>ICEfaces with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-penguincolony.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					The application manages details of penguins in a colony. To begin, click the <guibutton>Edit</guibutton> link in the first row of the table:
					ICEfaces and Metawidget work together to pop up an AJAX form without refreshing the page. Next, clear the form's
					<parameter>Name</parameter> box and tab to the next field: an AJAX call is made and a validation error appears. Try
					entering a new name and tabbing again: the validation error disappears and the new name is immediately reflected in
					the table behind the popup box.
				</para>
				
				<para>
					The remaining fields are wrapped in an ICEfaces <classname>PanelTabSet</classname>. Click on the <guibutton>Details</guibutton> tab.
					Here, the example makes use of the <classname>@UiAttribute</classname> annotation and <classname>FacesInspectionResultProcessor</classname>.
					The Java code is annotated:
				</para>
				
				<programlisting language="java">@UiAction
@UiAttribute( name = InspectionResultConstants.HIDDEN, value = "#{!empty _this.condition}" )
public void addCondition() { ... }

@UiAttribute( name = InspectionResultConstants.HIDDEN, value = "#{empty _this.condition}" )
public PenguinCondition getCondition() { ...}</programlisting>
				
				<para>
					Clicking the <guibutton>Add Condition</guibutton> button, or checking one of the <parameter>Hobbies</parameter> checkboxes,
					triggers an AJAX call that re-evaluates the	<classname>@UiAttribute</classname> annotations and dynamically reconstructs the
					form without requiring a page refresh. This includes removing existing buttons, creating new dropdown boxes and creating
					new labels.
				</para>
				
				<para>
					For more details on ICEfaces support, see <xref linkend="section-widgetbuilders-icefaces"/>
					and <xref linkend="section-layouts-web-faces-icefaces-paneltabset"/>.
				</para>
								
			</section>

			<section id="section-introduction-part3-ee6">
				<title>Java EE 6 Example</title>
				
				<para>
					There is a retrofitted version of the <filename>GatewayWarDeployment</filename> example from Adam Bien's
					<ulink url="http://press.adam-bien.com">Real World Java EE Patterns</ulink> book downloadable from his
					<ulink url="http://kenai.com/projects/javaee-patterns">Java EE Patterns and Best Practices Kenai Repository</ulink>.
				</para>
				
				<para>
					For more information, see
					<ulink url="http://blog.kennardconsulting.com/2010/12/retrofitting-ui-gatewaywardeployment.html">this blog entry</ulink>.				
				</para>
			</section>
			
			<section id="section-introduction-part3-swingappframework">
				<title>Swing AppFramework Example</title>
	
				<para>
					The Swing AppFramework Car Demo demonstrates using Metawidget with the
					<ulink url="https://appframework.dev.java.net">Swing AppFramework</ulink>. Metawidget
					can use Swing AppFramework's <classname>@Action</classname> annotation to identify actions, both amongst
					a domain object's properties and in external controllers, and automatically generate <classname>JButton</classname>s
					for them.
				</para>
	
				<para>
					The application is pre-built for you in <filename>examples/swing/appframework-swing.jar</filename> or you
					can build it yourself by changing to the <filename>src/examples/swing/appframework</filename> folder and typing:
				</para>
				
				<programlisting language="shell">mvn package</programlisting>
				
				<tip>
					<title>Note</title>
					This example uses annotations, so you'll need Java SE 5 or higher
				</tip>

				<para>
					This is a self-executing JAR. For convenience, it has <filename>MANIFEST.MF</filename> dependencies hard-wired into it to
					<filename>lib/AppFramework.jar</filename> among others, so it's best not to move
					it to a different folder (if you do, you'll need to manually put those JARs on your <parameter>CLASSPATH</parameter>).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples/swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar appframework-swing.jar</programlisting>
				
				<para>
					The opening screen displays two fields to allow you to enter the make and type of a car. You can also optionally
					add an owner by clicking the <guibutton>Add an Owner</guibutton> button, or save the car using the <guibutton>Save</guibutton>
					button.
				</para>
				
				<para>
					The <guibutton>Add an Owner</guibutton> button is generated by Metawidget based on the <function>addOwner</function> method
					in the <classname>Car</classname> class (which has been annotated <classname>@org.jdesktop.application.Action</classname>). The
					<guibutton>Save</guibutton> button is generated based on the <function>save</function> method in the <classname>CarApplication</classname>
					class (also annotated <classname>@Action</classname>). Two different Metawidgets are used in the example: one pointed
					at the <classname>Car</classname> class, the other at the <classname>CarApplication</classname> class.
				</para>
				
				<para>
					Metawidget supports pluggable 'action styles'. The use of Swing AppFramework is configured
					per <classname>Inspector</classname>, as in <filename>src/examples/swing/appframework/src/main/resources/org/metawidget/example/swing/appframework/metawidget.xml</filename>
					from the source distribution:
				</para>

				<programlisting language="xml">&lt;metawidgetAnnotationInspector config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
	&lt;actionStyle&gt;
		&lt;swingAppFrameworkActionStyle xmlns="java:org.metawidget.inspector.impl.actionstyle.swing"&gt;
	&lt;/actionStyle&gt;
&lt;/metawidgetAnnotationInspector&gt;</programlisting>

				<para>
					As a further feature, after the <guibutton>Add an Owner</guibutton> button is clicked it disappears. This is
					acheived by using <classname>JexlInspectionResultProcessor</classname> to introduce an expression language
					for Swing similar to JSP's EL. The method is annotated...
				</para>
				
				<programlisting language="java">@Action( name = "add" )
@UiAttribute( name = HIDDEN, value = "${this.owner != null}" )
public void addOwner() {
	mOwner = new Owner();
	fireActionEvent( "addOwner" );
}</programlisting>
				
				<para>
					...such that the button gets hidden when the car has an owner.
				</para>
				
			</section>

			<section id="section-introduction-part3-scala">
				<title>Scala Example</title>
	
				<para>
					The Scala Animal Races Example demonstrates using SwingMetawidget together with
					<ulink url="http://scala-lang.org">Scala</ulink> and
					<ulink url="http://miglayout.com">MigLayout</ulink>.
				</para>
	
				<para>
					The application is pre-built for you in <filename>examples/swing/animalraces-swing.jar</filename> or you can
					build it yourself by changing to the <filename>src/examples/swing/animalraces</filename> folder of the source
					distribution and typing:
				</para>
				
				<programlisting language="shell">mvn package</programlisting>
				
				<tip>
					<title>Note</title>
					This example uses annotations, so you'll need Java SE 5 or higher
				</tip>

				<para>
					This is a self-executing JAR. For convenience, it has <filename>MANIFEST.MF</filename> dependencies hard-wired into it to
					<filename>lib/scala-library.jar</filename> among others, so it's best not to move
					it to a different folder (if you do, you'll need to manually put those JARs on your <parameter>CLASSPATH</parameter>).
				</para>
				
				<para> 
					Run the code by navigating to the <filename>examples/swing</filename> folder and typing:
				</para>				
				
				<programlisting language="shell">java -jar animalraces-swing.jar</programlisting>
				
				<para>
					The screen displays fields to allow you to change the name, speed and type of each animal as well buttons
					to start and stop the race.
				</para>
				
				<figure id="section-introduction-part3-scala-screenshot">
					<title>Scala and MigLayout with Metawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/desktop-animalraces.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Animal Races' whimsical User Interface demonstrates how Metawidget's goal of not 'owning' the UI allows multiple
					Metawidgets to be combined for unconventional UIs. There are three Metawidgets across the top (one for each animal in
					the race), and a fourth Metawidget for the buttons at the bottom.
				</para>
				
				<para>
					The top three Metawidgets all use MigLayout. Because Metawidget does not hide the underlying UI framework, using
					MigLayout allows the Animal Races code to easily pad the Metawidget: 
				</para>

				<programlisting language="java">metawidget.setMetawidgetLayout( new MigLayout() );
metawidget.setToInspect( animal );
<symbol>((MigLayout) metawidget.getLayout()).setLayoutConstraints( new LC().insets( "10" ));</symbol></programlisting>

				<para>
					The Animal Races code is written purely in Scala, located at
					<filename>src/examples/swing/animalraces/src/main/scala/org/metawidget/example/swing/animalraces/AnimalRaces.scala</filename>. It uses
					<classname>ScalaPropertyStyle</classname> to allow Metawidget to inspect Scala-based domain objects: 
				</para>
				
				<programlisting language="xml">&lt;metawidgetAnnotationInspector xmlns="java:org.metawidget.inspector.annotation"
		config="org.metawidget.inspector.impl.BaseObjectInspectorConfig"&gt;
		&lt;propertyStyle&gt;
			<symbol>&lt;scalaPropertyStyle xmlns="java:org.metawidget.inspector.impl.propertystyle.scala"/&gt;</symbol>
		&lt;/propertyStyle&gt;			
	&lt;/metawidgetAnnotationInspector&gt;</programlisting>

				<para>
					In addition, it uses <classname>BeanUtilsBindingProcessorConfig.PROPERTYSTYLE_SCALA</classname> to bind <classname>JComponent</classname>s
					to Scala-based domain objects:
				</para>
					
				<programlisting language="scala">val metawidget = new SwingMetawidget()
<symbol>metawidget.addWidgetProcessor( new BeanUtilsBindingProcessor()
			.setPropertyStyle( BeanUtilsBindingProcessorConfig.PROPERTYSTYLE_SCALA ))</symbol>
metawidget.setToInspect( animal )</programlisting>

			</section>

			<section id="section-introduction-part3-gwt-clientside">
				<title>GWT Client Side Example</title>
	
				<para>
					By default, <classname>GwtMetawidget</classname> uses server-side inspection of domain objects. This
					is because client-side JavaScript does not support reflections or annotations. However if you don't need reflections or annotations, and
					have your own way of retrieving inspection results, you can plug in your own <classname>Inspector</classname> and keep everything client-side. This
					example implements a <classname>TextAreaInspector</classname> that retrieves inspection results from a textarea and generates the UI. 
				</para>

				<para>
					The GWT Client Side example is pre-built for you in <filename>examples/gwt/clientside-gwt</filename>. Because everything is purely
					client side, there is no need for Tomcat or any other container: simply navigate to the example
					folder and open <filename>index.html</filename> in your Web browser:
				</para>
				
				<figure id="section-introduction-part3-gwt-clientside-screenshot">
					<title>Client-Side GwtMetawidget</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-clientside.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					The example shows a <classname>textarea</classname> on the left containing inspection results in <filename>inspection-result-1.0.xsd</filename> format. The
					result of generating this XML is shown on the right. Click the <guibutton>Sample #2</guibutton> and <guibutton>Sample #3</guibutton>
					buttons to preload different XML samples, and the <guibutton>Generate</guibutton> button to generate their UI. Alternatively, you can edit
					the XML by hand to add new properties and actions and click <guibutton>Generate</guibutton>.
				</para>
				
				<para>
					Data binding and event binding are also implemented client side. Click the <guibutton>Save</guibutton> to save the data from the generated UI
					using a <classname>MapPropertyBinding</classname> (in a real application, this Map could be passed back to the server for
					persisting). Click the <guibutton>Add Tracks</guibutton> button to trigger an event binding.
				</para>
				
				<para>
					Finally, this example showcases using third-party GWT component libraries. <classname>ExtGwtWidgetBuilder</classname> is used
					to render a date picker widget. For more details on
					<ulink url="http://extjs.com/products/gxt">ExtGWT</ulink>
					support, see <xref linkend="section-widgetbuilders-gwt-extgwt"/>. 
				</para>
								
			</section>

			<section id="section-introduction-part3-gwt-hosted">
				<title>GWT Hosted Mode Examples</title>
	
				<para>
					The <filename>examples/gwt/addressbook-gwt.war</filename> (discussed in Part 2 of this tutorial)
					and the <filename>examples/gwt/clientside</filename> (discussed in Part 3 of this tutorial) demonstrates GWT
					running in <emphasis>GWT Web mode</emphasis>. Developers may prefer instead to run the examples in <emphasis>GWT hosted mode</emphasis>
					as in <xref linkend="section-introduction-part3-gwt-hosted-screenshot"/>.
				</para>

				<figure id="section-introduction-part3-gwt-hosted-screenshot">
					<title>Address Book Example running in GWT Hosted Mode</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-gwt-hosted.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					Source code for all examples can be found under the <filename>src/examples</filename> folder of the
					examples distribution. The code is organized into standalone Maven projects so that it can be easily imported
					into your favourite IDE. For example, to run the GWT Address Book example in Eclipse:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							Install <ulink url="http://m2eclipse.sonatype.org">m2eclipse</ulink>, then
							choose <parameter>File &gt; Import... &gt; Maven &gt; Existing Maven Projects</parameter>
						</para>
					</listitem>
					<listitem>
						<para>
							Navigate to <filename>src/examples/gwt/addressbook</filename> and choose to import <filename>pom.xml</filename> 
						</para>
					</listitem>
					<listitem>
						<para>
							The project may take a while to import and download dependencies (shown under Eclipse's <parameter>Console</parameter> tab).
							Afterwards, there will be build errors related to missing artifacts (shown under Eclipse's <parameter>Problems</parameter> tab)
						</para>
					</listitem>
					<listitem>
						<para>
							Right click the	project and choose <parameter>Run As &gt; Maven Build...</parameter> (note the ellipses).
							In the <parameter>Edit Configuration</parameter>
							dialog, remove <filename>/gwt/addressbook</filename> from the end of <parameter>Base directory</parameter>
							and enter <parameter>Goals</parameter> as:
						</para>
						<programlisting language="shell">-pl org.metawidget.examples.gwt:addressbook-gwt -am install</programlisting>
						<para>
							Click <parameter>Run</parameter> and wait for all artifacts to build. Again, this may take a while.							
						</para>
					</listitem>
					<listitem>
						<para>
							Choose <parameter>Project &gt; Update All Maven Dependencies</parameter>. The build errors should disappear.
						</para>
					</listitem>
					<listitem>
						<para>
							Install the <ulink url="http://code.google.com/eclipse">Google Plugin for Eclipse</ulink>, then
							right click the project and choose <parameter>Properties &gt; Google &gt; Web Toolkit</parameter> and click
							<parameter>Use Google Web Toolkit</parameter>.
						</para>
					</listitem>
					<listitem>
						<para>
							There will be a build error related to a missing <filename>web.xml</filename>. Right click the project
							and choose <parameter>Refresh</parameter>. The build error should disappear.
						</para>
					</listitem>
					<listitem>
						<para>
							Right click the project and choose <parameter>Run As &gt; Web Application</parameter>.
						</para>
					</listitem>
					<listitem>
						<para>
							Choose <filename>hosted.jsp</filename> (this is a simplified home page that doesn't invoke custom JSTL tags).
						</para>
					</listitem>
					<listitem>
						<para>
							Open the Google Development Mode view tab and double-click to open the URL in your browser.
						</para>
					</listitem>
				</itemizedlist>
				
				<important>
					<title>Check your Build Path</title>
					If Hosted Mode fails to start, right click the project and choose <parameter>Properties &gt; Java Build Path &gt; Libraries</parameter>.
					Check the build path does not include any GWT libraries outside of those in <parameter>Maven Dependencies</parameter>, and
					that the GWT version matches the one in <filename>src/examples/gwt/addressbook/pom.xml</filename>. 
				</important>
				
				<para>
					Once you have the samples running, you can quickly make changes and play around. For example:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>				
							Find the line in <classname>ContactDialog</classname> that configures a <classname>LabelLayoutDecorator</classname>
							(which decorates sections using <classname>Label</classname>s).
						</para>
					</listitem>
					<listitem>
						<para>
							Change it to a <classname>TabPanelLayoutDecorator</classname>. This will decorate sections using a GWT <classname>TabPanel</classname>.												
						</para>
					</listitem>
					<listitem>
						<para>
							Right click the <filename>pom.xml</filename> and choose <parameter>Run As &gt; Maven Package</parameter>
							(this step is only necessary because the GWT Address Book uses shared projects. Import the GWT Client Side
							project for an example configured to deploy immediately without needing this extra step).
						</para>
					</listitem>
					<listitem>
						<para>
							Refresh your browser. The application will be using <classname>TabPanel</classname>, as
							shown in <xref linkend="section-introduction-part3-gwt-hosted-screenshot-tabpanel"/>.
						</para>
					</listitem>
				</itemizedlist>
				
				<figure id="section-introduction-part3-gwt-hosted-screenshot-tabpanel">
					<title>Address Book Example using GWT TabPanel</title>
					<screenshot>
						<graphic fileref="images/screenshots/web-gwt-hosted-tabpanel.jpg" width="100mm" />
					</screenshot>
				</figure>
				
			</section>
			
			<section id="section-introduction-part3-static">
				<title>Static Metawidget Example</title>
	
				<para>
					Although Metawidget is focused on runtime UI generation, its static mode (see <xref linkend="section-metawidgets-static"/>) can
					sometimes be more appropriate. The <ulink url="http://jboss.org/forge">JBoss Forge</ulink> project provides a thorough, real
					world demonstration of static Metawidget in action. JBoss Forge uses Metawidget internally for its UI scaffolding generation.
				</para>

				<figure id="section-introduction-part3-static-screenshot">
					<title>Static Metawidget is used internally by JBoss Forge</title>
					<screenshot>
						<graphic fileref="images/screenshots/static.jpg" width="100mm" />
					</screenshot>
				</figure>

				<para>
					To try using static Metawidget inside JBoss Forge:
				</para>
				
				<itemizedlist>
					<listitem>
						<para>
							<ulink url="http://jboss.org/forge">Download</ulink> Forge
						</para>			
					</listitem>
					<listitem>
						<para>
							<ulink url="https://docs.jboss.org/author/display/FORGE/Installation">Install</ulink> it
						</para>			
					</listitem>
					<listitem>
						<para>
							Run it
						</para>			
					</listitem>
					<listitem>
						<para>
							Execute the following command:
						</para>
						<programlisting language="shell">$ run-url https://raw.github.com/forge/core/master/showcase/posale.fsh</programlisting>
					</listitem>
				</itemizedlist>
				
				<para>
					This runs a Forge script that automates the creation of a Java EE web application. Forge makes use of
					static Metawidget in several places, including: for the JSF components on the Create, Retrieve, Update and Delete
					(CRUD) screens; for the search filter criteria; for generating Java statements inside the JSF managed bean.  					
				</para>
				
				<para>
					Alternatively, there are Forge plugins that can generate scaffolds for different environments. For example the
					Spring plugin uses <classname>StaticSpringMetawidget</classname> to generate Spring scaffolds, and the AeroGear plugin
					uses <classname>StaticHtmlMetawidget</classname> to generate mobile scaffolds.
					For more information on JBoss Forge and how Metawidget relates to it, see the
					<ulink url="https://docs.jboss.org/author/display/FORGE/UI+Scaffolding">UI scaffolding section</ulink>
					of the Forge documentation.
				</para>
				
			</section>

		</section>

	</chapter>
